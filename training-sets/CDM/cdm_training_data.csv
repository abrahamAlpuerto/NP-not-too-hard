File Name,Content
Eligible_Collateral_Representation.txt,"Main Menu Eligible Collateral Representation Version: 5.13.0 On this page Introduction Within collateral documentation, it is common to detail what assets you will exchange with your counterparties, i.e., what you deem eligible collateral. Such information is found in bilateral legal document, custodian triparty agreements and is also used for other purposes where defining whether an asset is eligible to be used as collateral to mitigate risk on a defined set (portfolio) of financial instruments between parties. Data requirements to represent eligible collateral include common information such as, asset descriptors e.g. who issues the asset, the asset type, its maturity profile, any related agency credit risk rating, and if any collateral haircut is to be applied to the asset's value. Within legal collateral documents, the definition of eligible collateral can take several forms; some may want to list assets and the related eligibility information in table-format using common language, use textual description of types of eligible assets, or use common identifiers and taxonomies. However, it is evident for each method chosen there is no common data standard to express the same information for all the data attributes used. The financial crisis and the resulting regulatory framework that emerged from guidelines outlined under BCBS/IOSCO and Basel III has presented further requirements that define specific criteria for collateral eligibility that must be applied to portfolios. Observation of different regulations under various jurisdictions has presented several challenges for defining collateral asset economic identity, correct categorisation and application of specified haircuts and concentration limits. Having no common standards in place to represent the key data has led to lengthy negotiation, misinterpretation, lack of interoperability and downstream operational inefficiency. Eligible Collateral in the CDM The CDM provides a standard digital representation of the data required to express collateral eligibility for purposes such as representation in legal agreements that govern transactions and workflows. The benefits of this digital representation are summarized below: Provides a comprehensive digital representation to support the data requirements to universally identify collateral types. Includes ability to identify attributes of collateral that contribute to the risk like the type of asset, interest structures, economics, embedded options and unique characteristics. Uses data standards to specify eligibility related information such as haircuts (regulatory credit quality, FX related or additional haircuts), agency or composite credit ratings and asset maturity terms Provides functions to apply treatment rules to predefined collateral criteria such as include/exclude logic Applies treatment rules for concentration limits caps by percentage or value. These can be applied to one or multiple elements of the collateral characteristics and defined criteria Attributes are included to identify regulatory rules by defined eligibility identification categories published by regulatory bodies such as EMIR, CFTC and US Prudential Provides a means of Identifying Schedules and constructing reusable collateral profiles Standardises digital data representation components to construct the details to identify collateral eligibility not just for regulatory purposes but for all needs of eligibility expression within legal contracts and documentation Promotes a standard format to represent eligible collateral for negotiators to identify and agree details without misinterpretation Provides standards to facilitate Interoperability between platforms for digitised eligible collateral information Connects contractual terms of eligibility in documentation to supporting processes Standardises data records for audit requirements Provides many opportunities in the collateral ecosystem and benefits a data representation of collateral choices that can be imported and exported to other systems such as credit, treasury, trade reporting and custodian platforms, providing a full workflow solution from negotiation, execution through to optimisation and settlement. Modelling Approach Scope ​ The model's primary intention is to deliver standards for OTC Derivatives with a focus on uncleared margin rules. In addition, the approach is intended to also be used to express collateral eligibility for other industry workflows such as Securities Lending, Repo and Exchange Traded Derivatives (ETD). The model foundations, broad range of attributes and functions has been constructed with this in mind and can be extended further to operate to wider processes. The common data requirements have been established through industry working groups reviewing a wide range of examples in order to identify collateral for the purpose of constructing eligible collateral specifications, including representation of additional attributes for regulatory risk and credit factors. For the purpose of understanding the principle, these can be divided into the following categories: Issuer Identification Asset Identification Collateral Haircuts Maturity Ranges Concentrations Limits Treatments Functions The data attributes within the model provides the flexibility to firstly identify the collateral issuer and asset class, then define its maturity if relevant, then apply treatment rules for any chosen haircut percentages, concentration limits and inclusion or exclusion conditions. The combination of these terms allows a wide range of collateral and associated data for eligibility to be represented. Approach to identifying Collateral Assets ​ The universe of collateral used throughout the industry for risk mitigation purposes is vast and the intention is for the CDM to provide a standard means of identifying as much of this collateral universe as possible initially and then extend the model further as required via open-source contributions under the CDM governance structure. At the outset, there have been no common standards for describing collateral; the foundational structure in the CDM provides a means to identify a majority of collateral issuers and covers a wide range of asset types that are commonly seen in eligible collateral data. The approach in the CDM is to adopt a similar method to the 'Animal Kingdom' tree and taxonomy (kingdom → phylum → class → order→ family → genus → species) -- i.e., that there is one method for describing any of the core attributes of an ""animal"" (i.e., type of issuer/type of asset/type of economic terms) that need to be referenced, but only one way. Each issuer type, asset type, economic type etc has a unique place in the universe of collateral but is logically grouped together with similar types. An illustrative example for understanding the principle is shown here: The CDM method for representing eligible collateral will be capable of reference to, and inclusion in, common master and respective collateral documentation for OTC Derivatives and non- OTC master agreements (notably Repo and Securities Lending) and potentially for OTC Cleared and Exchange Traded Derivatives. For this reason, it is important that the CDM is able to accommodate Regulatory Uncleared Margin Rules concepts that are relevant but the model should not prescribed by them. Although the industry will benefit from using a digital standard to describe collateral, there is also a need to recognise that market participants may want to identify eligible collateral without fully describing every feature and instead use industry identifiers, where available. Thus, the CDM also provides a means that collateral issuers can be identified using common legal entity identifiers such as an LEI. Similarly, asset types can be identified using a product ID such as ISIN or CUSIP or a standard taxonomy source. High Level Design Principles ​ The foundational data structure from the highest level allows firstly to represent eligibility through specification of criteria : The Asset type is used to specify criteria related to the nature of the asset, such as its type (cash, debt, equity, or other), its country of origin or its denominated currency. The Issuer type is used to specify criteria related to the issuer of the asset, such the type of issuer (government, corporate, etc), specific issuer name, or agency rating Treatment is used to specify the valuation percentage, any concentration limits and or specific inclusion or exclusion conditions, which additionally apply to filter whether a piece of collateral is eligible or not. The combination of these terms allows a wide variety of eligible collateral types to be represented and a structure can be used to identify individual collateral types or a group of collateral assets for inclusion in specifying eligible collateral schedule details. Identifying Eligible Collateral using the CDM Data Structure A combination of data types can be used to describe the collateral asset, its origin and its issuer. Data type EligibleCollateralCriteria extends CollateralCriteriaBase and contains data types to enable to define collateral Asset and Issuer characterises Asset Criteria ​ The data type AssetCriteria is used to specify the definition of the collateral asset, this includes the following data attributes: type AssetCriteria: collateralAssetType AssetType (0..*) assetCountryOfOrigin ISOCountryCodeEnum (0..*) denominatedCurrency CurrencyCodeEnum (0..*) agencyRating AgencyRatingCriteria (0..*) maturityType MaturityTypeEnum (0..1) maturityRange PeriodRange (0..1) productIdentifier ProductIdentifier (0..*) collateralTaxonomy CollateralTaxonomy (0..*) domesticCurrencyIssued boolean (0..1) listing ListingType (0..1) condition AssetCriteriaChoice: optional choice collateralAssetType, collateralTaxonomy, productIdentifier collateralAssetType Represents a filter based on the asset product type. collateralAssetType Represents a filter based on the asset product type. assetCountryOfOrigin Represents a filter based on the issuing entity country of origin. denominatedCurrency Represents a filter based on the underlying asset denominated currency. agencyRating Represents an agency rating based on default risk and creditors claim in event of default associated with specific instrument. maturityType Specifies whether the maturity range is the remaining or original maturity. maturityRange Represents a filter based on the underlying asset maturity. productIdentifier Represents a filter based on specific instrument identifiers (e.g. specific ISINs, CUSIPs etc) collateralTaxonomy Specifies the collateral taxonomy, which is composed of a taxonomy value and a taxonomy source. domesticCurrencyIssued Identifies that the Security must be denominated in the domestic currency of the issuer. ListingType Specifies the exchange, index or sector specific to listing of a security. Each of the AssetCriteria data attributes in the model provides further granularity to describe the asset, either as basic types or complex types, for example: collateralAssetType can be used to define further by AssetType such as securityType , debtType , equityType , or fundType . Each of these can be used to represent data in further granularity if required providing more enumeration options. These are covered in further examples throughout this guide. assetCountryOfOrigin and denominatedCurrency are 'string' basic types and can be populated by a country name, code or currency abbreviations. domesticCurrencyIssued is a Boolean data attribute option to specify True or False. AgencyRatingCriteria and maturityType are explained in more detail in further examples throughout this guide. Issuer Criteria ​ The data type IssuerCriteria is used to specify the issuer of a collateral asset, this includes the following data attributes: type IssuerCriteria: issuerType CollateralIssuerType (0..*) issuerCountryOfOrigin ISOCountryCodeEnum (0..*) issuerName LegalEntity (0..*) issuerAgencyRating AgencyRatingCriteria (0..*) sovereignAgencyRating AgencyRatingCriteria (0..*) counterpartyOwnIssuePermitted boolean (0..1) issuerType Represents a filter based on the type of entity issuing the asset. issuerCountryOfOrigin Represents a filter based on the issuing entity country of origin, which is the same as filtering by eligible Sovereigns. issuerName Specifies the issuing entity name or LEI. issuerAgencyRating Represents an agency rating based on default risk and creditors claim in event of default associated with asset issuer. sovereignAgencyRating Represents an agency rating based on default risk of country. counterpartyOwnIssuePermitted Represents a filter based on whether it is permitted for the underlying asset to be issued by the posting entity or part of their corporate family. For each of the IssuerCriteria options, the model will provide further options of granularity; for example issuerType will allow you to define further express data for the detail to be more specific to the type of issuer for example: SovereignCentralBank , QuasiGovernment , RegionalGovernment and so on., If necessary, each will offer further levels of granularity relevant to each issuer type. These will be covered in more detail and in further examples throughout this guide. Other attributes of IssuerCriteria can be used and added to your issuer description, if required, and will give various levels of granularity dependent on their nature and purpose in describing the issuer. For example issuerCountryOfOrigin is a free format 'string' representation to be populated by a country name, code. counterpartyOwnIssuePermitted is a Boolean data option to specify Y/N. issuerName is used to express a legal entity id as a 'string'. Whereas, other attributes will have more detailed options such as IssuerAgencyRating These will be covered in more detail and in further examples throughout this guide. Treatment Functions Treatment rules can be applied to eligible collateral in several ways using data type CollateralTreatment which specifies the treatment terms for the eligible collateral criteria specified . This includes a number of options which are listed below: ValuationTreatment Specification of the valuation treatment for the specified collateral, such as haircuts percentages. concentrationLimit Specification of concentration limits applicable to the collateral criteria. isIncluded A boolean attribute to specify whether collateral criteria are inclusion (True) or exclusion (False) criteria . The CDM model is flexible so that these treatment rules can be applied to the detail of data expression for eligible collateral on an individual basis or across a group of issuer names or asset types or combinations of both. Each treatment function will have its own set of options and the model will provide further options of granularity. Valuation Treatments ​ CollateralValuationTreatment will allow for representation of different types of haircuts, as follows . Please note: data expression for percentages is a number with a condition to be expressed as a decimal between 0 and 1. haircutPercentage Specifies a haircut percentage to be applied to the value of asset and used as a discount factor to the value of the collateral asset, expressed as a percentage in decimal terms. marginPercentage Specifies a percentage value of transaction needing to be posted as collateral expressed as a valuation. fxHaircutPercentage Specifies an FX haircut applied to a specific asset which is agreed between the parties. AdditionalHaircutPercentage Specifies a percentage value of any additional haircut to be applied to a collateral asset, the percentage value is expressed as the discount haircut to the value of the collateral. Concentration Limits ​ ConcentrationLimit ,is another form of treatment which has a set of attributes which allow concentration limits to be defined in two alternative ways using ConcentrationLimitCriteria Generic method : If you wish to apply a concentration limit to a set of pre-defined eligible collateral details in the CDM, you would use ConcentrationLimitType , ConcentrationLimitTypeEnum which allows you to define which existing details to apply the concentration limit to from an enumeration list including (Asset, Base currency, Issuer, Primary Exchange, Sector.. etc) Specific method : If you wish to apply a concentration limit to a specific asset or issuer of asset, you would use the ConcentrationLimitCriteria . This extends CollateralCriteriaBase and allows you be more specific using the granular structures of the IssuerCriteria and AssetCriteria to specify the details of the issuer or asset you want to apply the concentration limit. In addition, you would need to specify the form of the Concentration limit being used as a value limit range to apply a cap (upper bound) or floor (lower bound) to the identified asset, issuer or attributes. There are two options that allow this to be represented in value or percentage terms as follows: type ConcentrationLimit: concentrationLimitCriteria ConcentrationLimitCriteria (0..*) valueLimit MoneyRange (0..1) percentageLimit NumberRange (0..1) ValueLimit Specifies the value of collateral limit represented as a range percentageLimit Specifies the percentage of collateral limit represented as a decimal number There are conditions in the CDM when applying concentration limits that constrain choices to: one of the concentration limit methods (either a limit type or limit criteria must be specified) one concentration limit type (either a value limit or percentage limit concentration must be specified) Inclusion Rules ​ The collateral treatment function isIncluded can be used as a treatment term for the eligible collateral criteria specified and indicate if the collateral is eligible or not. Therefore a Boolean data attribute is applied using one of the following: (True) Collateral Inclusion (False) Collateral Exclusion Additional Granular Information for Eligible Collateral Data Construction The CDM data structure to express collateral eligibility has been explored in more detail and it has been demonstrated where the EligibleCollateralCriteria can be broken down into data related to IssuerCriteria and AssetCriteria and rules can be applied using data for CollateralTreatment. The following section focuses on the more granular details of the various data attributes available through IssuerCriteria and AssetCriteria . Collateral Asset and Issuer Types ​ Under data types for both IssuerCriteria and AssetCriteria the first data attributes available to detail collateral are issuerType and collateralAssetType these will offer additional data. Defining Collateral Issuers: issuerType allows for multiple expressions of data related to the issuer using CollateralIssuerType containing data attributes as follows: issuerType IssuerTypeEnum Specifies the origin of entity issuing the collateral with the following enumerations shown as examples but not limited to: SupraNational SovereignCentralBank RegionalGovernment Corporate Some attributes are extended to allow further granularity as shown in the examples below: supraNationalType Represents types of supranational entity issuing the asset, such as international organisations and multilateral banks -- with enumerations to define: InternationalOrganisation MultilateralBank Defining Collateral Assets: collateralAssetType allows for multiple expressions of data related to the collateral asset using AssetType which has further data attributes as follows: assetType - Represents the type of collateral asset with data attributes as enumerations to define Security Cash Commodity Other Collateral Products securityType - Represents the type of security with data attributes to define, as examples: Debt Equity Fund debtType - Represents a filter based on the type of bond which includes further optional granularity for certain characteristics that may be required to define specific details related to debt type assets such but not limited to as follows: DebtClass Asset Backed Convertible RegCap Structured DebtEconomics Debt Seniority Secured Senior Subordinated Debt Interest Fixed Floating Inflation Linked Debt Principal Bullet Callable Puttable Amortising A similar structure exists for equityType and fundType and other collateral assets types. As well as defining the details of the asset and issuer of collateral using the various attributes available in the CDM description tree, there are other detailed criteria that may be required to define collateral and for use in expressing eligibility details; the guide will detail these and indicate the data structure available to define them. Agency Ratings Criteria (Used within both Issuer and Asset Criteria) ​ The use of specifying agency rating criteria for credit purposes can be useful for many means in legal documentation to drive operational outcomes such as collateral thresholds and event triggers. When defining collateral eligibility, the CDM can represent collateral underlying credit default risk in various ways by using agency rating sources. These are useful and common for determining eligible collateral between parties and those defined under regulatory rules for posting certain margin types. The model components are specified in the CDM using data type AgencyRatingCriteria : - Represents class to specify multiple credit notations alongside a conditional 'any' or 'all' qualifier. For the purpose of use in defining eligible collateral this can be applied to the following data attributes: IssuerCriteria > issuerAgencyRating - Represents an agency rating based on default risk and creditors claim in event of default associated with asset issuer IssuerCriteria > sovereignAgencyRating - Represents an agency rating based on default risk of the country of the issuer AssetCriteria > agencyRating - Represents an agency rating based on default risk and creditors claim in event of default associated with specific instrument Data type AgencyRatingCriteria Allows specification of the following related information to eligible collateral type AgencyRatingCriteria: qualifier QuantifierEnum (1..1) creditNotation CreditNotation (1..*) mismatchResolution CreditNotationMismatchResolutionEnum (0..1) referenceAgency CreditRatingAgencyEnum (0..1) boundary CreditNotationBoundaryEnum (0..1) qualifier Indicator for whether all or any of the agency ratings specified apply using the All or Any enumeration contained within QuantifierEnum creditNotation Indicates the agency rating criteria specified for the asset or issuer. This expands to offer further granularity for details relating to the credit details type CreditNotation: agency CreditRatingAgencyEnum (1..1) notation string (1..1) [metadata scheme] scale string (0..1) [metadata scheme] debt CreditRatingDebt (0..1) outlook CreditRatingOutlookEnum (0..1) creditWatch CreditRatingCreditWatchEnum (0..1) CreditRatingAgencyEnum A list of enumerated values to specify the rating agency or agencies, (all major rating agencies are supported) notation Specifies the credit rating notation. As itvaries among credit rating agencies, the CDM does not currently specify each specific rating listed by each agency. The data'string' allows the free format field to be populated with a rating , such as 'AAA' scale Specifies the credit rating scale, with a typical distinction between short term, long term. The data 'string' allows the free format field to be populated with a scale indicator such as 'long term', 'short term'. debt Specifies the credit rating debt type is for any credit notation associated debt related credit attributes if needed. This gives the additional flexibility option to identify amongst the credit criteria debt characteristics such as (high yield, deposits, investments grade) The data type extends to offer two options debtType This attribute is free format 'string' and used when only one debt type is specified debtTypes This allows you to specify for than one multiple debt type characteristics and has a qualifying conditions to specify if you wish to include 'All' or 'Any' of the elements listed in scope outlook This data attributes allows you to specify the a credit rating outlook assessment that is commonly determine by rating agencies. It is an indication of the potential direction of a long-term credit rating over the intermediate term, which is generally up to two years for investment grade and generally up to one year for speculative grade. The enumeration list allows you to specify if required one of the following outlook terminology Positive (A rating may be raised) Negative (A rating may be lowered) Stable (A rating is not likely to change) Developing (A rating may be raised, lowered, or affirmed) creditWatch Similar to detailing a type of credit outlook, credit agencies will also identify individual credit by a means of a monitoring (watch) status for an undefined period. This watch status can be expressed using the following data terminology under this enumeration list. Positive (A rating may be raised) Negative (A rating may be lowered) Developing (A rating may be raised, lowered, or affirmed) mismatchResolution If several agency issue ratings are being specified that are not necessarily equivalent of each, this data attribute allows you to label which one has certain characteristics amongst the others, such as lowest or highest etc, the following enumerations are available: Lowest Highest Reference Agency Average Second Best enum CreditNotationMismatchResolutionEnum: Lowest Highest ReferenceAgency Average SecondBest referenceAgency This part of the agency rating criteria again allows you to specify from the list of enumerated values for the rating agency. But in this case it is to identify the rating agency if you need to determine one from others if you used the data attribute referenceAgency in the CreditNotationMismatchResolutionEnum as outlined above. boundary Indicates the boundary of a credit agency rating i.e minimum or maximum. A condition exists If the mismatch resolution choice is ReferenceAgency , you must ensure that the reference agency is specified through the CreditRatingAgencyEnum For example: Through CreditNotation the following data has been specified: S&P AAA Moodys Aaa Fitch AAA Then one of these needed to be specified as the dominant rating as an example (Moodys), you would express mismatchResolution > CreditNotationMismatchResolutionEnum > ReferenceAgency referenceAgency > CreditRatingAgencyEnum > Moodys Collateral Taxonomy (Used within Asset Criteria) ​ It is understood that data used to determine asset types used in specifying eligible collateral information can often refer to common structured standard pre-defined taxonomy sources. Although the purpose of the CDM is to encourage one standard representation of data for asset types, there are circumstances where assets are organised and labelled into categories, such as by regulators. In some circumstances, it may be a requirement to refer to these identifiable sources. In the CDM, these taxonomy sources can be referenced in a consistent representation. The CDM allows the definition of, and reference to, certain taxonomy sources to be used to express details for eligibility. These can be used as an additional means of expressing asset types outside of the descriptions tree or alongside it. Under data type AssetCriteria there are data attributes to reference collateral related taxonomy sources as follows: Data Type collateralTaxonomy will allow for specification of the collateral taxonomy, which is composed of a taxonomy value and a taxonomy source. The data attribute taxonomySource must be specified and will provide the following options through the enumerations list: CFI (The ISO 10962 Classification of Financial Instruments code) ISDA (The ISDA product taxonomy) ICAD (ISDA Collateral Asset Definition Identifier code) EU EMIR Eligible Collateral Asset Class (European Union Eligible Collateral Assets classification categories based on EMIR Uncleared Margin Rules) UK EMIR Eligible Collateral Asset Class (UK EMIR Eligible Collateral Assets classification categories based on UK EMIR Uncleared Margin Rules) US CFTC PR Eligible Collateral Asset Class (US Eligible Collateral Assets classification categories based on Uncleared Margin Rules published by the CFTC and the US Prudential Regulators) The options CFI, ISDA and ICAD would be further expressed with the flexible data 'string' representation through data type ProductTaxonomy . However the regulatory 'Eligible Collateral Asset Class' rules have individual enumeration lists unique to their asset class categories identified under each of the respective regulatory bodies. Therefore if these are selected as taxonomy sources through TaxonomySourceEnum it is required to specify details from the related unlimited enumeration lists that exist under data type CollateralTaxonomyValue, these are shown below: eu_EMIR_EligibleCollateral uk_EMIR_EligibleCollateral us_CFTC_PR_EligibleCollateral nonEnumeratedTaxonomyValue Please note: The regime codes are not mandatory and are based on reference to the regulatory eligible categories, but do not qualify the regulations. The CDM only provides a standard data representation so that institutions can recognise the same information. Each enumeration has a full description of what regulatory published rules the list of eligible collateral assets classification codes/categories are based on. Under each enumeration list there are a number of categorised eligible asset groups which have been identified under each set of regulatory rules. Some limited examples of these are shown below which are contained in the EU_EMIR_EligibleCollateralEnum list: EU_EMIRTypeA -Denotes Cash in the form of money credited to an account in any currency, or similar claims for the repayment of money, such as money market deposits. EU_EMIRTypeB - Denotes gold in the form of allocated pure gold bullion of recognised good delivery. EU_EMIRTypeC -Denotes debt securities issued by Member States' central governments or central banks. The cardinality for these enumeration lists (0.. * ) denotes that multiple values can be provided so several categories can be applied to a line of data expressed in an eligibility profile. The final attribute in CollateralTaxonomyValue , nonEnumeratedTaxonomyValue , offers additional data expression outside of the listed taxonomy values, for use when a taxonomy value is not enumerated in the model. There are conditions associated to the use of the data attributes within CollateralTaxonomyValue to ensure correct use of the data. These conditions enforce the specified regulatory enumerated list to match the taxonomy source. Therefore as an example you can only specify a category from the EMIR enumerations list if the taxonomy source is EU_EMIR_EligibleCollateralAssetClass Maturity Profiles (Used within Asset Criteria) ​ The expression of collateral life span periods and specific maturity dates is a common eligibility characteristic and may be needed for determining other key collateral treatments such as haircut percentages. The CDM has various approaches for representing assets maturities, they are data attributes within the data type AssetCriteria as follows: maturityType - Allows specification of the type of maturity range and has the following enumerated values: Remaining Maturity Original Maturity From Issuance maturityRange Allows filtering on the underlying asset maturity through definition of a lower and upper bound range using data type PeriodRange . Using PeriodBound for both ends of the scale you would need to specify the period, for example: lowerBound 1Y , representing one year using the Period > periodMultiplier 1 and period PeriodEnum Y upper bound 5Y, representing 5 years using the Period > periodMultiplier 5 and period PeriodEnum Y In addition PeriodBound has the inclusive boolean to indicate whether the period bound is inclusive, e.g. for a lower bound, false would indicate greater than, whereas true would indicate greater than or equal to. A combination of these data attributes combined allows specificity of the maturity profile of collateral asset types and definition of a range that would sit alongside the other asset data criteria. Multiple maturity ranges can be listed for and associated to one asset type, varied collateral treatment haircuts can then be added to each of the ranges, this would be a common feature of a collateral eligibility schedule especially if there is an uncleared margin rules regulatory requirement. Product Identifier (Used within Asset Criteria) ​ The CDM model as described throughout this guide will allow the user to define collateral assets through the granular structure of the AssetCriteria , but we must understand that expression of asset details for eligibility purposes can take other forms across the universe of collateral, for some processes there is a requirement to use certain product identifiers. Data type productIdentifier can be used to express specific instrument identifiers such as ISINs, CUSIPs etc. There is a section within the CDM documentation that covers this area of the model, this can be found in the following link products-with-identifiers-section . Listing (Used within Asset Criteria) ​ Additional details may be required to describe asset characteristics related to a securities financial listing, exchange, sector or specified indices, if relevant these are used to express eligibility details in documentation and collateral profiles. The data type listing ListingType contained within AssetCriteria can be used to specification such listing criteria. This expands to three attributes that can be used individually or together : exchange string (0..1) Represents a filter based on the primary stock exchange facilitating the listing of companies, exchange of Stocks, Exchange traded Derivatives, Bonds, and other Securities. sector string (0..1) Represents a filter based on an industry sector defined under a system for classifying industry types such as 'Global Industry Classification Standard (GICS)' and 'North American Industry Classification System (NAICS) or other related industry sector reference data. index Index (0..1) -- Represents a filter based on an index that measures a stock market, or a subset of a stock market. The ` Index ` data type can be used in the CDM to define an index in terms of a ` ProductIdentifier' and an enumeration identifying the index constituent type. Using The CDM Data Representation to Construct Eligible Collateral Information This user guide provides an overview of the data available to represent details for expressing eligibility inclusive of the asset criteria, issuer criteria and the collateral treatment inclusion rules, valuation percentages and concentration limits. However, a combination of how the data is represented and structured will determine specific outcomes. The data can be specified and organised as a list of attributes, such as descriptive details of the asset and the issuer, to identify the makeup of collateral. This list can be made up of multiple attributes from both the asset or issuer criteria and be grouped together. Items listed in this way using the same level in the CDM are defined as an 'and' relationship. However, opportunities exist in the CDM data structure to extended lists within a list and add another level to both asset and issuer criteria which will operate as an 'or' relationship. An example of this would be within data type AssetCriteria there is an option to define a denominatedCurrency (0.. * ); this data attribute with an open cardinality allows for a definition of a list of currencies and describes where a 'or' relationship exists. Each list combination identified in this way can then have specific treatment rules applied to it. For example, a simple list can be constructed as follows: AssetCriteria > collateralAssetType > assetType: CASH denominatedCurrency: USD And then the following treatment applied to the list Treatment > isIncluded: TRUE haircutPercentage : 0.005 The outcome is- USD CASH IS ELIGIBLE AT 99.5% VALUE/ or WITH 0.5% HAIRCUT To extend this example further a digital JSON output extract of the same details is show here: { ""criteria"": [{ ""asset"": [{ ""collateralAssetType"": [{ ""assetType"": ""CASH"" }], ""denominatedCurrency"": [{ ""value"": ""USD"" }] }], ""treatment"": { ""haircutPercentage"": { ""haircutPercentage"": 0.005 }, ""isIncluded"": true }"
CDM_Structured_Products_Working_Group.txt,"Main Menu CDM Structured Products Working Group Version: 5.13.0 On this page CDM Structured Products Working Group Overview ​ This working group aims to accelerate the build and support of structured products in the Common Domain Model. Meetings ​ Join us Monthly on the Second Tuesday 10AM EST (3PM GMT). Email to be added to the meeting invites directly, or find the meeting in the . ​ To subscribe to the Structured Products WG mailing list and stay updated on meetings and agenda, please send an email to structured-products+subscribe@lists.finos.org . After sending the email, you will receive a confirmation message. Reply to confirm your subscription. To view meeting notes and agendas, view our current and past GitHub Meeting Issues."
Download_Source_Code.txt,"Main Menu Download Source Code Version: 5.13.0 On this page Download Source Code The CDM source code is open source and can be downloaded from _ CDM GitHub . All released versions are tagged and can be downloaded from CDM GitHub Releases . Versions ​ The CDM code is tagged using semantic versioning and is available on GitHub Releases . All CDM Binary distributions are created on every release and are all published to Maven Central . CDM as Java ​ The CDM is distributed in Java and is available in Maven Central . Setup ​ In order to use the CDM in a Maven project, the following dependency needs to be added to the project pom.xml: dependency <groupId>org.finos.cdm</groupId> <artifactId>cdm-java</artifactId> <version>LATEST</version> NOTE: All current CDM dependencies are available in Maven Central. CDM releases prior to version 4.0.0 can be found in the ISDA repository: https://europe-west1-maven.pkg.dev/production-208613/isda-maven . The dependencies of CDM releases prior to version 4.0.0 can be found in the REGnosys repository: https://europe-west1-maven.pkg.dev/production-208613/public-maven . Add the following snippet to the <repositories> section of your project pom.xml : < repositories > <!-- remove references to REGnosys Jfrog --> < repository > < id > isda-maven </ id > < url > https://europe-west1-maven.pkg.dev/production-208613/isda-maven </ url > < releases > < enabled > true </ enabled > </ releases > < snapshots > < enabled > false </ enabled > </ snapshots > </ repository > < repository > < id > public-maven </ id > < url > https://europe-west1-maven.pkg.dev/production-208613/public-maven </ url > < releases > < enabled > true </ enabled > </ releases > < snapshots > < enabled > false </ enabled > </ snapshots > </ repository > <!-- existing contents --> </ repositories > CDM as Java Examples ​ Examples of how you can use the CDM can be found in GitHub: CDM GitHub Examples . CDM as Python ​ CDM as Python is published here . Then click on the Browse button for latest version available as .tar.gz file . CDM as DAML ​ CDM as DAML is published here . Then click on the Browse button for latest version available as .tar.gz file containing compiled .dar files. CDM as Scala ​ CDM as Scala is published here . Then click on the Browse button for latest version available as .jar file . CDM as C# 8.0 ​ CDM as C# 8.0 is published here . Then click on the Browse button for latest version available as a tar.gz file containing compiled .dll files. CDM as C# 9.0 ​ CDM as C# 9.0 is published here . Then click on the Browse button for latest version available as a tar.gz file containing compiled .dll files. CDM as Go ​ CDM as Go is files published here . Then click on the Browse button for latest version available as a tar.gz file containing the .go CDM as TypeScript ​ CDM as TypeScript is published here . Then click on the Browse button for latest version available as a zip file containing the .ts files. CDM as Kotlin ​ CDM as Kotlin is published here . Then click on the Browse button for latest version available as a .jar file. CDM as Excel ​ CDM as Excel is published here . Then click on the Browse button for latest version available as a .xlsx file containing CDM Types, Attributes and Enums. CDM as JSON Schema ​ CDM as JSON Schema is published here . Then click on the Browse button for latest version available as a zip file containing the .json schema files. CDM Event Specification Module as DAML ​ CDM Event Specification Module as DAML is available here ."
Securities_Lending.txt,"Main Menu Securities Lending Version: 5.13.0 On this page Securities Lending Introduction ​ The CDM is a data model that provides a standard format for financial products and transactions in the capital markets industry. It is intended to improve data quality, increase efficiency, and reduce costs by creating a common language that enables automated trade processing and reduces the need for costly customisations. The International Securities Lending Association ( ISLA ) have been working with securities financing subject matter experts to model components in the CDM for the Securities Lending market. Scope ​ A securities lending transaction involves the loan of securities by one party (the "" lender "") to another (the "" borrower ""), often facilitated by a brokerage firm or agent, with the borrower providing collateral and paying a fee. Securities lending products, trades and transactions can all be represented using the types, structures and functions in the CDM. The legal agreements that govern the trades can also be described and attached to the trades themselves. The model supports open or term cash and non-cash collateralised loans, using either fixed or floating rates, on a principal or agency basis. Core lifecycle events including trade execution, settlement, returns, allocation and reallocation are supported, with a basic billing function also provided. Core elements in Securities Lending ​ There are several types, attributes and functions that should be used to describe securities lending products and lifecycle events. The core elements required are described in this section, with examples of their usage. Cash Collateral ​ In a cash loan, the lender lends the borrower the requested securities, and the borrower provides cash as collateral against the securities that they are borrowing. Loans against cash collateral are formed as a ContractualProduct that includes an InterestRatePayout for the cash collateral, held under economicTerms->collateral , and an AssetPayout for the security being lent, held under economicTerms->payout . The collateralType under collateralProvisions should be set to "" Cash "" to define this as a cash collateralised loan. These types can be found under the economicTerms->collateral type. An example showing the location of the payouts for the cash collateral and the security being lent is provided below: ""economicTerms"": { ""payout"": { ""assetPayout"": [ { ... } ] }, ... ""collateral"": { ""collateralProvisions"": { ""collateralType"": ""Cash"" }, ""collateralPortfolio"": [ { ""collateralPosition"": [ { ""product"": { ""contractualProduct"": { ""economicTerms"": { ""payout"": { ""interestRatePayout"": [ { ... } ] } } } } } ] } ] }, ... } Non-cash Collateral ​ In a non-cash loan, the lender lends the borrower the requested securities, and the borrower provides collateral in the form of other securities or products. Loans against non-cash collateral are formed as a ContractualProduct that includes an AssetPayout for the non-cash collateral, held under economicTerms->collateral , and another AssetPayout for the security being lent, held under economicTerms->payout . The collateralType under collateralProvisions should be set to "" NonCash "" to define this as a non-cash collateralised loan. These types can be found under the economicTerms->collateral type. An example showing the location of the payouts for the non-cash collateral and the security being lent is provided below: ""economicTerms"": { ""payout"": { ""assetPayout"": [ { ... } ] }, ... ""collateral"": { ""collateralProvisions"": { ""collateralType"": ""NonCash"" }, ""collateralPortfolio"": [ { ""collateralPosition"": [ { ""product"": { ""contractualProduct"": { ""economicTerms"": { ""payout"": { ""assetPayout"": [ { ... } ] } } } } } ] } ] }, ... } Cash Pool ​ In a cash pool loan, the lender lends the borrower the requested securities, and takes cash as collateral from a cash pool held by the lender on behalf of the borrower. Loans against cash collateral are formed as a ContractualProduct that includes an InterestRatePayout for the cash collateral, held under economicTerms->collateral , and an AssetPayout for the security being lent, held under economicTerms->payout . The collateralType under collateralProvisions should be set to "" CashPool "" to define this as a cash pool collateralised loan. These types can be found under the economicTerms->collateral type. Please see the preceding example for a securities lending trade collateralised using cash for an example of where the payouts can be found. Defining Collateral ​ When non-cash collateral is used as collateral on a trade then it needs to be defined in the AssetPayout of the product. This can be done using the security type under securityInformation . The details of the security should be entered in the attributes held within the security->productIdentifier type, being the identifier and the source . Parties, Party Roles and Counterparties ​ The parties on a trade are defined in Party objects. These can be the lender and the borrower (i.e. the counterparties) or custodians or agency lenders. Details of each party should be defined in its own Party object. The role of each party can be defined in the PartyRole type. Using metadata keys and references each Party can then be associated to its role . The counterparties on a trade can be defined using the Counterparty type. This abstracts the role of each counterparty away from the actual parties on the trade, allowing them to be set as either "" Party1 "" or "" Party2 "".  The counterparties must reference a Party object which can again be done using metadata to avoid duplication. Payer and Receiver ​ The InterestRatePayout and AssetPayout types must also define the payer and receiver under the payerReceiver type. The payer and receiver must reference the counterparties on the trade using their roles on that trade i.e. either "" Party1 "" or "" Party2 "". The counterparty under the tradableProduct can be used to set which of the Party objects is which party. In securities lending the borrower is considered the payer as they are providing the collateral (either cash or non-cash), and the lender is the receiver of the collateral. Interest Rate, Price, Quantity and Value ​ The key factors that affect the earnings on a securities lending trade are the interest rate, price, loan quantity and loan value. These are all held in the priceQuantity type, which is represented as a list, allowing multiple items to be specified. Note: where a trade has multiple lots associated to it, each tradeLot can have a different priceQuantity associated to it, allowing each lot to have its own factors defined. A securities lending trade will need to include a minimum of two items in the priceQuantity list - one to describe the asset price and the quantity of shares of that asset; and another to describe the interest rate and the value to which the rate is to be applied. Price and Quantity ​ The priceQuantity will need to include a price that holds the asset price and a quantity that holds the number of shares on loan. It is also possible to define the security that the price and quantity are associated to in the observable type. The price will need to have its priceType set to "" AssetPrice "". The simplest way to express the price is using the value attribute, an example of which would be as follows: ""priceQuantity"": [ { ... ""price"" : [ { ""value"" : { ""value"" : 25, ""unit"" : { ""currency"" : { ""value"" : ""GBP"" } }, ""perUnitOf"" : { ""financialUnit"" : ""Share"" }, ""priceType"" : ""AssetPrice"" } } ] ... } ] The quantity will need to define the number of shares in the value attribute: ""priceQuantity"": [ { ... ""quantity"" : [ { ""value"" : { ""value"" : 0, ""unit"" : { ""financialUnit"" : ""Share"" } } } ] ... } ] If the security on loan is to be defined here then an observable should be included in the priceQuantity too: ""priceQuantity"": [ { ... ""observable"" : { ""productIdentifier"" : [ { ""value"" : { ""identifier"" : { ""value"" : ""GB00BDR05C01"" }, ""source"" : ""ISIN"" } } ] } ... } ] Note: the security on loan can also be defined under the product -> security details Interest Rate and Value ​ The priceQuantity will need to include a price that represents the interest rate and a quantity that holds the value that the interest rate is to be applied to. The price will need to have its priceType set to "" InterestRate "". The simplest way to express the rate is using the value attribute, an example of which would be as follows: ""priceQuantity"": [ { ... ""price"" : [ { ""value"" : { ""value"" : 0.01, ""unit"" : { ""currency"" : { ""value"" : ""GBP"" } }, ""perUnitOf"" : { ""currency"" : { ""value"" : ""GBP"" } }, ""priceType"" : ""InterestRate"" } } ] ... } ] The quantity will need to define the value that the rate is applied to in the value attribute: ""priceQuantity"": [ { ... ""quantity"" : [ { ""value"" : { ""value"" : 10000000, ""unit"" : { ""currency"" : { ""value"" : ""GBP"" } } } } ] ... } ] Dates ​ There are several key dates through the lifecycle of a securities lending trade. The main ones that need to be defined are described in this section. Effective Date ​ The effective date in a securities lending trade refers to the date when the agreement or transaction between the lender and the borrower becomes binding and takes effect. It signifies the point at which the terms and conditions of the lending arrangement are legally enforceable. The effectiveDate can be found under the product's economicTerms type. Trade Date ​ The trade date is the specific day when the order to lend securities is executed or placed in the market. The trade date marks the initiation of the transaction, while the effective date represents the point at which the agreement becomes legally binding. Once the trade has been executed then the tradeDate under the trade type should be set to the date the trade was executed. Settlement Dates ​ The settlement date is when the securities legally change hands. In a securities lending trade, there are potentially two dates related to settlement: the security settlement date, and for a trade against cash, the cash settlement date. The security settlement date is when the securities on the trade are legally transferred from the lender to the borrower. It is the day when the borrower becomes the holder of record of the security. For cash trades the cash settlement date is the date when the cash payment for the borrowed securities is made by the borrower to the lender. It represents the completion of the financial aspect of the securities lending transaction. In both instances the settlement dates are defined under the payouts associated to the trade. For a trade against non-cash there would be two assetPayouts , one for the non-cash collateral and another for the securities being lent. At a minimum the settlementDate under settlementTerms in the assetPayout for the security being lent should be populated. However, it is recommended that the settlementDate under both assetPayout -> settlementTerms types are set. For a trade against cash there would be an assetPayout for the securities being lent and an interestRatePayout for the cash being used as collateral. The security settlement date should be placed in the settlementDate under settlementTerms in the assetPayout , and the cash settlement date should be placed in the settlementDate under settlementTerms in the interestRatePayout . Note: For DVP trades the cash and security settlement dates will be the same. They should still be set under the assetPayout->settlementTerms->settlementDate and interestRatePayout->settlementTerms->settlementDate types as described above. Termination Date ​ Where a trade has a termination date this can be set under the terminationDate of the product's economicTerms type. Additional details related to the termination of a trade can be placed within the terminationProvision type also under economicTerms . Legal Agreement ​ The agreement governing a trade should be referenced in the contractDetails type under trade . For securities lending trades the ISLA Global Master Securities Lending Agreement can be referenced by setting the publisher to "" ISLA "" and the agreementName->masterAgreementType to "" GMSLA "". The preprint version can also be set in the vintage attribute. These attributes are available under the legalAgreementIdentification type, an example of which is provided below: ""contractDetails"": { ""documentation"": [ { ""legalAgreementIdentification"": { ""agreementName"": { ""masterAgreementType"": { ""value"": ""GMSLA"" } }, ""publisher"": ""ISLA"", ""vintage"": 2010 } } ] } Note: further details of the master agreement can be modelled in the masterAgreementSchedule which is also provided underneath the documentation type. Haircut and Margin ​ In a securities lending trade, a haircut is a reduction applied to the value of the collateral used for a loan and is generally expressed as a percentage. A margin is the initial market value of the collateral expressed as a percentage of the market price. These concepts can be represented using attributes under collateralProvisions under the product's economicTerms . Note: these attributes are expressed as decimal numbers. Thus a 50% haircut would be represented as ""0.5"", and a 110% margin would be represented as ""1.1"". An example of a trade that has a 10% haircut and 105% margin would look as follows: ""economicTerms"": { ""collateral"": { ""collateralProvisions"": { ""eligibleCollateral"": [ { ""treatment"": [ { ""valuationTreatment"": { ""haircutPercentage"": 0.1, ""marginPercentage"": 1.05 } } ] } ] } } }"
Reference_Data_Model.txt,"Main Menu Reference Data Model Version: 5.13.0 Reference Data Model The CDM only integrates the reference data components that are specifically needed to model the in-scope products, events, legal agreements and function components. This translates into the representation of the party and legal entity . Parties are not explicitly qualified as a legal entity or a natural person, although the model provides the ability to associate a person (or set of persons) to a party, which use case would imply that such party would be a legal entity (even if not formally specified as such). The LegalEntity type is used when only a legal entity reference is appropriate i.e. the value would never be that of a natural person. type Party: [metadata key] partyId PartyIdentifier (1..*) name string (0..1) [metadata scheme] businessUnit BusinessUnit (0..*) person NaturalPerson (0..*) personRole NaturalPersonRole (0..*) account Account (0..1) contactInformation ContactInformation (0..1) type NaturalPerson: [metadata key] personId PersonIdentifier (0..*) [metadata scheme] honorific string (0..1) firstName string (0..1) middleName string (0..*) initial string (0..*) surname string (0..1) suffix string (0..1) dateOfBirth date (0..1) type LegalEntity: [metadata key] entityId string (0..*) [metadata scheme] name string (1..1) [metadata scheme]"
CDM_Derivatives_Product_and_Business_Event_Working_Group.txt,"Main Menu CDM Derivatives Product and Business Event Working Group Version: 5.13.0 On this page CDM Derivatives Product and Business Event Working Group Overview ​ Focused on swaps (IR, credit, equity, commodity, etc.), options, FX, post-trade events (increases, novations, exercises, etc.) Meetings ​ Join us on the Second and Last Wednesday at 11:30 AM EST (4:30PM GMT). Email to be added to the meeting invites directly, or find the meeting in the . 2024 Roadmap ​ ​ To subscribe to the DPBE mailing list and stay updated on meetings and agenda, please send an email to cdm-dpbe-wg+subscribe@lists.finos.org . After sending the email, you will receive a confirmation message. Reply to confirm your subscription. To view meeting notes and agendas, view our current and past GitHub Meeting Issues."
Mapping_(Synonym).txt,"Main Menu Mapping (Synonym) Version: 5.13.0 Mapping (Synonym) In order to facilitate the translation of existing industry messages (based on open standards or proprietary ones) into CDM, the CDM is mapped to a set of those alternative data representations using the Rosetta DSL synonym feature, as described in the Mapping Component Section . The following set of synonym sources are currently in place for the CDM: FpML standard (synonym source: FpML_5_10 ): synonyms to the version 5.10 of the FpML standard FIX standard (synonym source: FIX_5_0_SP2 ): synonyms to the version 5.0 SP2 of the FIX protocol ISO 20022 standard (synonym source: ISO_20022 ): synonyms to the ISO 20022 reporting standard, with no version reference at present Workflow event (synonym source: Workflow_Event ): synonyms to the event.xsd schema used internally in Rosetta to ingest sample lifecycle events DTCC (synonym sources: DTCC_11_0 and DTCC_9_0 ): synonyms to the OTC_Matching_11-0.xsd schema used for trade matching confirmations, and to the OTC_Matching_9-0.xsd schema used for payment notifications, both including the imported FpML schema version 4.9. CME (synonym sources: CME_ClearedConfirm_1_17 and CME_SubmissionIRS_1_0 ): synonyms to the cme-conf-ext-1-17.xsd schema (including the imported FpML schema version 5.0) used for clearing confirmation, and to the bloombergTradeFixml schema (including the imported FpML schema version 4.6) used for clearing submission AcadiaSoft (synonym source: AcadiaSoft_AM_1_0 ): synonyms to version 1.0 of AcadiaSoft Agreement Manager ISDA Create (synonym source: ISDA_Create_1_0 ): synonyms to version 1.0 of the ISDA Create tool for Initial Margin negotiation ORE (synonym source: ORE_1_0_39 ): synonyms to version 1.0.39 of the ORE XML Model Those synonym sources are listed as part of a configuration file in the CDM using a special synonym source enumeration, so that the synonym source value can be controlled when editing synonyms."
Use_Cases.txt,"Main Menu Use Cases Version: 5.13.0 On this page Use Cases Introduction ​ The Common Data Model is a powerful framework that offers a multitude of use cases across various industries and sectors. The standardisation that it provides allows firms to integrate it into different systems and platforms, promoting interoperability and data exchange across the entire market. Documentation on some of the common use cases for the model is provided here. Eligible Collateral Representation ​ The CDM provides a standard data format to represent all the information required to define collateral eligibility, including asset descriptors, issuer details, asset type, maturity profile, credit risk rating, and collateral haircut. Please see Eligible Collateral Representation for more details. Repurchase Agreement Representation ​ Repurchase transactions and lifecycle events are represented in the CDM, with support for basic repo transactions, fixed term repo, open repo, fixed rate and floating rate and buy/sell-back transactions. Please see Repurchase Agreement Representation for more details. Securities Lending ​ Securities lending products, trades and transactions are all provided by the CDM, allowing open or term cash and non-cash collateralised loans, using either fixed or floating rates, on a principal or agency basis, to be represented. Please see Securities Lending for more details. Pre-trade Processing ​ Pre-trade processing refers to the various steps and procedures that market participants undertake before a trade is executed. The goal of this processing is to ensure that trades are executed efficiently and in compliance with regulatory requirements. Please see Pre-trade Processing for more details."
Process_Model.txt,"Main Menu Process Model Version: 5.13.0 On this page Purpose Why a Process Model ​ The CDM lays the foundation for the standardisation, automation and inter-operability of industry processes . Industry processes represent events and actions that occur through the transaction's lifecycle, from negotiating a legal agreement to allocating a block-trade or calculating settlement amounts. While ISDA defines the protocols for industry processes in its library of ISDA Documentation, differences in the implementation minutia may cause operational friction between market participants. Evidence shows that even when calculations are defined in mathematical notation (for example, day count fraction formulae which are used when calculating interest rate payments) can be a source of dispute between parties in a transaction. What Is the Process Model ​ The CDM Process Model has been designed to translate the technical standards that support those industry processes into a standardised machine-readable and machine-executable format. Machine readability and executability is crucial to eliminate implementation discrepancy between market participants and increase interoperability between technology solutions. It greatly minimises the cost of adoption and provides a blueprint on which industry utilities can be built. How Does It Work ​ The data and process model definitions of the CDM are systematically translated into executable code using purpose-built code generation technology. The CDM executable code is available in a number of modern, widely adopted and freely available programming languages and is systematically distributed as part of the CDM release. The code generation process is based on the Rosetta DSL and is further described in the Code Generation Section , including an up-to-date list of available languages . Support for further languages can be added as required by market participants. Scope The scope of the process model has two dimensions: Coverage - which industry processes should be covered. Granularity - at which level of detail each process should be specified. Coverage ​ The CDM process model currently covers the post-trade lifecycle of securities, contractual products, and foreign exchange . Generally, a process is in-scope when it is already covered in ISDA Documentation or other technical documents. For example, the following processes are all in scope: Trade execution and confirmation Clearing Allocation Reallocation Settlement (including any future contingent cashflow payment) Return (settlement of the part and/or full return of the loaned security as defined by a Securities Lending transaction.) Billing (calculation and population of invoicing for Securities Lending transactions) Exercise of options Margin calculation Regulatory reporting (although covered in a different documentation section) Granularity ​ It is important for implementors of the CDM to understand the scope of the model with regard to specifications and executable code for the above list of post-trade lifecycle processes. The CDM process model leverages the function component of the Rosetta DSL. A function receives a set of input values and applies logical instructions to return an output. The input and output are both CDM objects (including basic types). While a function specifies its inputs and output, its logic may be fully defined or only partially defined depending on how much of the output's attribute values it builds. Unspecified parts of a process represent functionality that firms are expected to implement, either internally or through third-parties such as utilities. It is not always possible or practical to fully specify the business logic of a process from a model. Parts of processes or sub-processes may be omitted from the CDM for the following reasons: The sub-process is not needed to create a functional CDM output object. The sub-process has already been defined and its implementation is widely adopted by the industry. The sub-process is specific to a firm's internal process and therefore cannot be specified in an industry standard. Given these reasons, the CDM process model focuses on the most critical data and processes required to create functional objects that satisfy the below criterion: All of the qualifiable constituents (such as BusinessEvent and Product ) of a function's output can be qualified, which means that they evaluate to True according to at least one of the applicable Qualification functions. Lineage and cross-referencing between objects is accurate for data integrity purposes. For any remaining data or processes, implementors can populate the remaining attribute values required for the output to be valid by extending the executable code generated by the process model or by creating their own functions. For the trade lifecycle processes that are in scope, the CDM process model covers the following sub-process components, which are each detailed in the next sections: Validation process Calculation process Event creation process Validation Process ​ In many legacy models and technical standards, validation rules are generally specified in text-based documentation, which requires software engineers to evaluate and translate the logic into code. The frequently occuring result of this human interpretation process is inconsistent enforcement of the intended logic. By contrast, in the CDM, validation components are an integral part of the process model specifications and are distributed as executable code in the Java representation of the CDM. The CDM validation components leverage the validation components of the Rosetta DSL. Product Validation ​ As an example, the FpML ird validation rule #57 , states that if the calculation period frequency is expressed in units of month or year, then the roll convention cannot be a weekday. A machine readable and executable definition of that specification is provided in the CDM, as a condition attached to the CalculationPeriodFrequency type: condition FpML_ird_57: if period = PeriodExtendedEnum -> M or period = PeriodExtendedEnum -> Y then rollConvention <> RollConventionEnum -> NONE and rollConvention <> RollConventionEnum -> SFE and rollConvention <> RollConventionEnum -> MON and rollConvention <> RollConventionEnum -> TUE and rollConvention <> RollConventionEnum -> WED and rollConvention <> RollConventionEnum -> THU and rollConvention <> RollConventionEnum -> FRI and rollConvention <> RollConventionEnum -> SAT and rollConvention <> RollConventionEnum -> SUN Calculation Process ​ The CDM provides certain ISDA Definitions as machine executable formulas to standardise the industry calculation processes that depend on those definitions. Examples include the ISDA 2006 definitions of Fixed Amount and Floating Amount , the ISDA 2006 definitions of Day Count Fraction rules, and performance calculations for Equity Swaps. The CDM also specifies related utility functions. These calculation processes leverage the calculation function component of the Rosetta DSL which is associated to a [calculation] annotation. Explanations of these processes are provided in the following sections. Base Libraries - Vector Math ​ The CDM includes a very basic library for performing vector math. This is intended to support more complex calculations such as daily compounded floating amounts. The CDM includes a basic implementation of these functions in Java, and allows individual implementations to substitute their own more robust representations. A small library of functions for working with vectors (ordered collections of numbers) has been added to CDM to support Rosetta functions needing to perform complex mathematical operations. Anticipated uses include averaging and compounding calculations for floating amounts, but the functions are designed to be general use. The functions are located in base-math-func . Functions include: VectorOperation : Generates a result vector by applying the supplied arithmetic operation to each element of the supplied left and right vectors in turn. i.e. result [ n ] = left [ n ] [ op ] right [ n ] , where [ op ] is the arithmetic operation defined by arithmeticOp. This function can be used to, for example, multiply or add two vectors. VectorScalarOperation : Generates a result vector by applying the supplied arithmetic operation and scalar right value to each element of the supplied left vector in turn. i.e. result [ n ] = left [ n ] [ op ] right, where [ op ] is the arithmetic operation defined by arithmeticOp. This function can be used to, for example, multiply a vector by a scalar value, or add a scalar to a vector. VectorGrowthOperation : Generates a result vector by starting with the supplied base value (typically 1), and then multiplying it in turn by each growth factor, which is typically a number just above 1. For instance, a growth factor of 1.1 represents a 10% increase, and 0.9 a 10% decrease. The results will show the successive results of applying the successive growth factors, with the first value of the list being the supplied baseValue, and final value of the results list being the product of all of the supplied values. i.e. result [ 1 ] = baseValue * factor [ 1 ] , result [ n ] = result [ n-1 ] * factor [ n ] . The resulting list will have the one more element than the supplied list of factors. This function is useful for performing compounding calculations. AppendToVector : Appends a single value to a vector. Also a new scalar functions has been added to better support floating rate processing: RoundToPrecision : Rounds a supplied number to a specified precision (in decimal places) using a roundingMode of type RoundingDirectionEnum . This is similar to RoundToNearest but takes a precision rather than an amount, and uses a different rounding mode enumeration that supports more values. Base Libraries - Date Math ​ The CDM includes a very basic library for performing date math. This is intended to support more complex calculations such as daily compounded floating amounts. The CDM includes a basic implementation of these functions in Java, and allows individual implementations to substitute their own more robust representations. A small library of functions for working with dates and lists of dates has been added to CDM to support Rosetta functions needing to perform date mathematics. Anticipated uses include date list generation for modular rate calculations for floating amounts, but the functions are designed to be general use. There is a basic Java language implementation that can be used, or users can provide their own implementations of these functions using a more robust date math library. The functions are located in base-datetime-func . Functions include: GetAllBusinessCenters : Returns a merged list of BusinessCenterEnums for the supplied BusinessCenters. BusinessCenterHolidaysMultiple : Returns a sorted list of holidays for the supplied business centers. BusinessCenterHolidays : Returns a list of holidays for the supplied business center. DayOfWeek : Returns the day of week corresponding to the supplied date. AddDays : Adds the specified number of calendar days to the supplied date. A negative number will generate a date before the supplied date. DateDifference : Subtracts the two supplied dates to return the number of calendar days between them . A negative number implies first is after second. LeapYearDateDifference : Subtracts the two supplied dates to return the number of leap year calendar days between them (that is, the number of dates that happen to fall within a leap year). A negative number implies firstDate is after secondDate. AppendDateToList : Add a date to a list of dates. PopOffDateList : Remove last element from a list of dates. The following are implemented in Rosetta based on the above primitives: IsWeekend : Returns whether the supplied date is a weekend. This implementation currently assumes a 5 day week with Saturday and Sunday as holidays. A more sophisticated implementation might use the business centers to determine which days are weekends, but most jurisdictions where derivatives are traded follow this convention. IsHoliday : Returns whether a day is a holiday for the specified business centers. IsBusinessDay : Returns an indicator of whether the supplied date is a good business date given the supplied business centers. True = > good date, i.e. not a weekend or holiday. False means that it is either a weekend or a holiday. AddBusinessDays : Returns a good business date that has been offset by the given number of business days given the supplied business centers. A negative value implies an earlier date (before the supplied originalDate), and a positive value a later date (after the supplied date). GenerateDateList : Creates a list of good business days starting from the startDate and going to the end date, inclusive, omitting any days that are weekends or holidays according to the supplied business centers. Base Libraries - Daycounting ​ The CDM includes a library for performing day counting calculations. It includes functions as follows: * YearFraction : The fraction of a year represented by a date range. * YearFractionForOneDay [: Return the year fraction represented by a single day, i.e. 1 / dayCountBasis, where dayCountBasis represents the denominator of the day count fraction. This perhaps should take into account leap years, though the ISDA compounding formulas do not cover ACT basis at the moment. * DayCountBasis : Return the day count basis (the denominator of the day count fraction) for the day count fraction. Floating Rate Option/Index Features ​ The CDM includes features for retrieving information about floating rate options and for calculating custom (""modular"") floating rates. Functions for retrieving information about FROs include: IndexValueObservation : Retrieve the values of the supplied index on the specified observation date. IndexValueObservationMultiple : Retrieve the values of the supplied index on the specified observation dates. FloatingRateIndexMetadata : Retrieve all available metadata for the floating rate index. ValidateFloatingRateIndexName : Return whether the supplied floating rate index name is valid for the supplied contractual definitions. Functions for calculating modular floating rates include: EvaluateCalculatedRate : Evaluate a calculated rate as described in the 2021 ISDA Definitions, Section 7 GenerateObservationDatesAndWeights : Apply shifts to generate the list of observation dates and weights for each of those dates. ComputeCalculationPeriod : Determine the calculation period to use for computing the calculated rate (it may not be the same as the normal calculation period, for instance if the rate is set in advance) DetermineObservationPeriod : Determine any applicable offsets/shifts for the period for observing an index, and then generate the date range to be used for observing the index, based on the calculation period, plus any applicable offsets/shifts. GenerateObservationPeriod : Generate the date range to be used for observing the index, based on the calculation period, plus any applicable offsets/shifts. GenerateObservationDates : Generate the list of observation dates given an observation period. DetermineWeightingDates : Determine the dates to be used for weighting observations. ProcessObservations : Apply daily observation parameters to rate observation. These are discussed in the 2021 ISDA Definitions, section 7.2.3 and 7.2.4. GenerateWeights : Recursively creates a list of weights based on the date difference between successive days. ApplyCompoundingFormula : Implements the compounding formula: Product of ( 1 + (rate * weight) / basis), then backs out the final rate. This is used to support section 7.3 of the 2021 ISDA Definitions. ApplyAveragingFormula : Implements the weighted arithmetic averaging formula. Sums the weighted rates and divides by the total weight. This is used to support section 7.4 of the 2021 ISDA Definitions. Fixed Amount and Floating Amount Definitions ​ The CDM includes preliminary features for calculating fixed and floating amounts for interest rate payouts. Base calculation functions include: FixedAmountCalculation : Calculates the fixed amount for a calculation period by looking up the notional and the fixed rate and multiplying by the year fraction GetFixedRate : Look up the fixed rate for a calculation period FloatingAmountCalculation : Calculate a floating amount for a calculation period by determining the raw floating rate, applying any rate treatments, looking up the calculation period notional, then performing the multiplication of the notional, rate, and year fraction. Floating amount calculations are described in the 2021 ISDA Definitions in Section 6 and 7. GetNotionalAmount : Look up the notional amount in effect for a calculation period GetQuantityScheduleStepValues : Find all schedule step values whose stepDate is before or equal to the supplied periodStartDate. Returns a list of step values starting from the initial quantity value, to the last step value before the periodStartDate. CalculateYearFraction : Calculate the year fraction for a single calculation period, by invoking the base year fraction logic Floating rate processing an calculation functions include: DetermineFloatingRateReset : Get the value of a floating rate by either observing it directly or performing a rate calculation. This function works differently depending on the rate category and style, as described in the 2021 ISDA Definitions, Section 6.6. GetFloatingRateProcessingType : Get a classification of the floating rate is processed. This is based on FRO category, style, and calculation method, as described in the 2021 ISDA Definitions Section 6.6. The categorization information is obtained from the FRO metadata. ProcessFloatingRateReset : Entry point for the function that performs the floating rate resetting operation. There are different variations depending on the processing type (e.g. screen rate, OIS, modular calculated rate). GetCalculatedFROCalculationParameters : Initialize a calculation parameters block for an OIS or a daily average rate. Used to support FROs that include an embedded calculation. ProcessFloatingRateReset(processingType: FloatingRateIndexProcessingTypeEnum->CompoundIndex) : Call the compounded index processing logic to calculate the reset EvaluateScreenRate : Evaluate/lookup the value of a screen rate DetermineResetDate : Determine the value of the reset date given a reset dates structure and a calculation period for which it's needed. Reset dates are defined in the 2021 ISDA Definition in Section 6.5.5. DetermineFixingDate : Determine the observation (fixing) date needed given a reset dates structure and a reset date. GetFloatingRateProcessingParameters : Determine the processing parameters to use from the InterestRatePayout by looking them up if necessary from the corresponding schedules in the interest rate stream SpreadAmount : Look up the spread amount for a calculation period. MultiplierAmount : Look up the multiplier amount for a calculation period. CapRateAmount : Look up the cap rate amount for a calculation period. FloorRateAmount : Look up the floor rate amount for a calculation period. GetRateScheduleAmount : Look up an amount for a calculation period from a rate schedule ApplyFloatingRateProcessing : Perform rate treatments on floating rates, such as applying spreads, multipliers, caps and floors, rounding, and negative interest treatment. ApplyFloatingRatePostSpreadProcessing : Perform post-spread rate treatments on floating rates, such as applying caps and floors, rounding, and negative interest treatment. ApplyCapsAndFloors : Apply any cap or floor rate as a constraint on a regular swap rate, as discussed in the 2021 ISDA Definitions, section 6.5.8 and 6.5.9 ApplyUSRateTreatment : Apply the US rate treatment logic where applicable (Bond Equivalent Yield, Money Market Yield, as described in the 2021 ISDA Definitions, section 6.9. (NB: this function does not have an implementation.) ApplyFinalRateRounding : Apply the final rate rounding treatment logic as described in the 2021 ISDA Definitions, section 4.8.1. Most of the above have a preliminary implementation for feedback. A few are only defined as ""do-nothing"" interfaces, and users needing these features would need to implement the functions. Fixed Amount and Floating Amount Definitions ​ The CDM expressions of FixedAmount and FloatingAmount are similar in structure: a calculation formula that reflects the terms of the ISDA 2006 Definitions and the arguments associated with the formula. func FloatingAmount: [calculation] inputs: interestRatePayout InterestRatePayout (1..1) rate number (0..1) notional number (0..1) date date (0..1) calculationPeriodData CalculationPeriodData (0..1) output: floatingAmount number (1..1) alias calculationPeriod: if calculationPeriodData exists then calculationPeriodData else CalculationPeriod(interestRatePayout -> calculationPeriodDates, date) alias calcPeriodBase : Create_CalculationPeriodBase(calculationPeriod) alias floatingCalc : FloatingAmountCalculation(interestRatePayout, calcPeriodBase, False, notional, rate) set floatingAmount : floatingCalc-> calculatedAmount Year Fraction ​ The CDM process model incorporates calculations that represent the set of day count fraction rules specified as part of the ISDA 2006 Definitions, e.g. the ACT/365.FIXED and the 30E/360 day count fraction rules. Although these rules are widely accepted in international markets, many of them have complex nuances which can lead to inconsistent implementations and potentially mismatched settlements. For example, there are three distinct rule sets in which the length of each month is generally assumed to be 30 days for accrual purposes (and each year is assumed to be 360 days). However there are nuances in the rule sets that distinguish the resulting calculations under different circumstances, such as when the last day of the period is the last day of February. These distinct rule sets are defined by ISDA as 30/360 (also known as 30/360 US), 30E/360 (formerly known as 30/360 ICMA or 30/360 Eurobond), and the 30E/360.ISDA. The CDM process model eliminates the need for implementors to interpret the logic and write unique code for these rules. Instead, it provides a machine-readable expression that generates executable code, such as the example below: func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> _30E_360): [calculation] alias startYear: startDate -> year alias endYear: endDate -> year alias startMonth: startDate -> month alias endMonth: endDate -> month alias endDay: Min(endDate -> day, 30) alias startDay: Min(startDate -> day, 30) set result: (360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360 Utility Function ​ CDM elements often need to be transformed by a function to construct the arguments for a formula in a calculation. A typical example is the requirement to identify a period start date, end date, and other date-related attributes required to compute a cashflow amount in accordance with a schedule (as illustrated in the day count fraction calculation shown above). The CDM has two main types to address this requirement: CalculationPeriodDates specifies the inputs required to construct a calculation period schedule CalculationPeriodData specifies actual attribute values of a calculation period such as start date, end date, etc. The CalculationPeriod function receives the CalculationPeriodDates and the current date as the inputs and produces the CalculationPeriodData as the output, as shown below: func CalculationPeriod: inputs: calculationPeriodDates CalculationPeriodDates (1..1) date date (1..1) output: result CalculationPeriodData (1..1) Equity Performance ​ The CDM process model includes calculations to support the equity performance concepts applied to reset and pay cashflows on Equity Swaps. Those calculations follow the definitions as normalised in the new 2018 ISDA CDM Equity Confirmation for Security Equity Swap (although this is a new template that is not yet in use across the industry). Some of those calculations are presented below: func EquityCashSettlementAmount: inputs: tradeState TradeState (1..1) date date (1..1) output: equityCashSettlementAmount Transfer (1..1) alias equityPerformancePayout: tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout only-element alias equityPerformance: EquityPerformance(tradeState ->trade, tradeState -> resetHistory only-element -> resetValue, date) alias payer: ExtractCounterpartyByRole( tradeState -> trade -> tradableProduct -> counterparty, equityPerformancePayout -> payerReceiver -> payer ) -> partyReference alias receiver: ExtractCounterpartyByRole( tradeState -> trade -> tradableProduct -> counterparty, equityPerformancePayout -> payerReceiver -> receiver ) -> partyReference set equityCashSettlementAmount -> quantity -> value: Abs(equityPerformance) set equityCashSettlementAmount -> quantity -> unit -> currency: ResolveEquityInitialPrice( tradeState -> trade -> tradableProduct -> tradeLot only-element -> priceQuantity -> price ) -> unit -> currency set equityCashSettlementAmount -> payerReceiver -> payerPartyReference: if equityPerformance >= 0 then payer else receiver set equityCashSettlementAmount -> payerReceiver -> receiverPartyReference: if equityPerformance >= 0 then receiver else payer set equityCashSettlementAmount -> settlementDate -> adjustedDate: ResolveCashSettlementDate(tradeState) set equityCashSettlementAmount -> settlementOrigin -> performancePayout: equityPerformancePayout as-key func RateOfReturn: inputs: initialPrice PriceSchedule (1..1) finalPrice PriceSchedule (1..1) output: rateOfReturn number (1..1) alias initialPriceValue: initialPrice->value alias finalPriceValue: finalPrice->value set rateOfReturn: if finalPriceValue exists and initialPriceValue exists and initialPriceValue > 0 then (finalPriceValue - initialPriceValue) / initialPriceValue Billing ​ The CDM process model includes calculations to support the billing event consisting of the individual amounts that need to be settled in relation to a portfolio of Security Loans. These calculations leverage the FixedAmount , FloatingAmount and Day Count Fraction calculations described earlier in the documentation. A functional model is provided to populate the SecurityLendingInvoice data type following the definitions as normalised in the ISLA best practice handbook The data type and function to generate a Security Lending Invoice: type SecurityLendingInvoice: [rootType] [metadata key] sendingParty Party (1..1) receivingParty Party (1..1) billingStartDate date (1..1) billingEndDate date (1..1) billingRecord BillingRecord (1..*) billingSummary BillingSummary (1..*) func Create_SecurityLendingInvoice: inputs: instruction BillingInstruction (1..1) output: invoice SecurityLendingInvoice (1..1) set invoice -> sendingParty: instruction -> sendingParty set invoice -> receivingParty: instruction -> receivingParty set invoice -> billingStartDate: instruction -> billingStartDate set invoice -> billingEndDate: instruction -> billingEndDate add invoice -> billingRecord: Create_BillingRecords( instruction -> billingRecordInstruction ) add invoice -> billingSummary: Create_BillingSummary( invoice -> billingRecord ) Lifecycle Event Process While the lifecycle event model described in the event-model-section provides a standardised data representation of those events using the concept of primitive event components, the CDM must further specify the processing of those events to ensure standardised implementations across the industry. This means specifying the logic of the state-transition as described by each primitive event component. In particular, the CDM must ensure that: The lifecycle event process model constructs valid CDM event objects. The constructed events qualify according to the qualification logic described in the event-qualification-section . The lineage between states allows an accurate reconstruction of the trade's lifecycle sequence. There are three levels of function components in the CDM to define the processing of lifecycle events: Primitive creation Event creation Workflow step creation Each of those components can leverage any calculation or utility function already defined in the CDM. As part of the validation processe embedded in the CDM, an object validation step is included in all these object creation functions to ensure that they each construct valid CDM objects. Further details on the underlying calculation and validation processes are described in the calculation-process and validation-process . Illustration of the three components are given in the sections below. Primitive Creation ​ Primitive creation functions can be thought of as the fundamental mathematical operators that operate on a trade state . While a primitive event object describes each state transition in terms of before and after trade states, a primitive creation function defines the logic to transition from that before trade state to the after trade state, using a set of instructions . An example of such use is captured in the reset event of an Equity Swap. The reset is processed in following steps: Resolve the Observation that contains the equity price, using specific product definition terms defined on EquityPayout . Construct a Reset using the equity price on Observation . In this scenario, the reset value is the equity price. Append Reset onto TradeState , creating a new instance of TradeState . At the end of each period in the life of the Equity Swap, the reset process will append further reset values onto the trade state . The series of equity prices then supports equity performance calculation as each reset value will represent the equity price at the end of one period and the start of the next. These above steps are codified in the Create_Reset function, which defines how the Reset instance should be constructed. func Create_Reset: inputs: instruction ResetInstruction (1..1) tradeState TradeState (1..1) output: reset TradeState (1..1) alias payout: instruction -> payout alias observationDate: if instruction -> rateRecordDate exists then instruction -> rateRecordDate else instruction -> resetDate alias observationIdentifiers: if payout -> performancePayout count = 1 then ResolvePerformanceObservationIdentifiers(payout -> performancePayout only-element, instruction -> resetDate) else if payout -> interestRatePayout exists then ResolveInterestRateObservationIdentifiers(payout -> interestRatePayout only-element, observationDate) alias observation: ResolveObservation([observationIdentifiers], empty) set reset: tradeState add reset -> resetHistory: if payout -> performancePayout count = 1 then ResolvePerformanceReset(payout -> performancePayout only-element, observation, instruction -> resetDate) else if payout -> interestRatePayout exists then ResolveInterestRateReset(payout -> interestRatePayout, observation, instruction -> resetDate, instruction -> rateRecordDate) First, ResolvePerformanceObservationIdentifiers defines the specific product definition terms used to resolve ObservationIdentifier s. An ObservationIdentifier uniquely identifies an Observation , which inside holds a single item of market data and in this scenario will hold an equity price. Specifying precisely which attributes from PerformancePayout should be used to resolve the equity price is important to ensure consistent equity price resolution for all model adopters. func ResolvePerformanceObservationIdentifiers: inputs: payout PerformancePayout (1..1) adjustedDate date (1..1) output: identifiers ObservationIdentifier (1..1) alias adjustedFinalValuationDate: ResolveAdjustableDate( payout -> valuationDates -> valuationDatesFinal -> valuationDate ) alias valuationDates: if adjustedDate < adjustedFinalValuationDate then payout -> valuationDates -> valuationDatesInterim else payout -> valuationDates -> valuationDatesFinal add identifiers -> observable -> productIdentifier: payout -> underlier -> security -> productIdentifier set identifiers -> observationDate: AdjustedValuationDates( payout -> valuationDates ) filter item <= adjustedDate then last set identifiers -> observationTime: ResolvePerformanceValuationTime(valuationDates -> valuationTime, valuationDates -> valuationTimeType, identifiers -> observable -> productIdentifier only-element, valuationDates -> determinationMethod ) set identifiers -> determinationMethodology -> determinationMethod: valuationDates -> determinationMethod ResolveObservation provides an interface for adopters to integrate their market data systems. It specifies the input types and the output type, which ensures the integrity of the observed value. func ResolveObservation: inputs: identifiers ObservationIdentifier (1..*) averagingMethod AveragingCalculationMethod (0..1) output: observation Observation (1..1) The construction of the Reset in our scenario then becomes trivial, once the equity price has been retrieved, as the equity price and reset date are simply assigned to the corresponding attributes on the Reset . func ResolvePerformanceReset: inputs: performancePayout PerformancePayout (1..1) observation Observation (1..1) date date (1..1) output: reset Reset (1..1) set reset -> resetValue: observation -> observedValue set reset -> resetDate: date add reset -> observations: observation Workflow Step Creation ​ ( This feature is currently being developed and will be documented upon release in the CDM )"
Development_Guidelines.txt,"Main Menu Development Guidelines Version: 5.13.0 On this page Governance The Common Domain Model is an open standard project hosted under FINOS, the Fintech Open Source Foundation , starting in February 2023. The standard is developed through the Community Specification open governance process, and underlying code assets are released under the Community Specification License 1.0 . For versions before 4.0.0 and other license details, check Notice.md . For a more detailed overview of the existing Working Group and standard Participants, Editors and Maintainers, please see Governance.md . For more information on discussions and announcements subscribe to our mailing list using the following link . A proposal can be defined at a conceptual level or a logical level (i.e. in code). In each case, the proposal must be developed in line with the CDM design-principles and agile-development-approach and submitted to FINOS staff and the Architecture & Review Committee for approval. In some instances, the proposal may not be immediately approved but may be assigned to an existing or new Working Group for the purpose of reviewing, revising or extending the proposal. Once approved, the amendment will be scheduled to be merged with the CDM's main code branch by the CDM Maintainers. Roles ​ The CSL specifies three different contribution roles for each specific Working Group: Maintainers - those who drive consensus within the working group Editors - those who codify ideas into a formal specification Participants - anyone who provides contributions to the project under a signed CSL CLA. A great way to sign the CLA is to open a Pull Request to add your name to the Participants.md file. Working Groups 2.1.0 Any Participant may propose a Working Group. Proposals for the formation of a new Working Group are made by completion of a new CDM Working Group template, clearly stating the objectives, deliverables and committed maintainers/editors for the proposed Working Group. 2.1.1 Approval of Specification Changes by Working Groups. Participants of each Working Group approve the “proposed” changes from that working group; the “approved changes” within a given Working Group will be brought to the Steering Working Group as a proposed “Pre-Draft” contribution. Participants of the CDM Steering Working Group approve DRAFT specification releases. Maintainers of the CDM Steering Working Group will approve merging of the proposed “Pre-Draft” changes (coming from other Working Groups or otherwise from community) into the repo. 2.2.0 CDM Steering Working Group. The CDM Steering Working Group will review and approve completed Working Group formation proposals per 2.1.0. 2.2.1 CDM Steering Working Group Purpose: The Steering Working Group is responsible for developing the technical and modelling guidelines, setting and revising the project’s strategic roadmap, and for vetting proposed changes. The CDM Steering Working Group may approve or establish additional working groups. 2.2.2 Appointment of CDM Steering Working Group Maintainers: At the launch of the project, up to two initial Maintainers will be nominated by ICMA, ISDA, and ISLA (collectively, the “trade associations”). Additional CDM Steering Group Maintainers may be proposed by Participants. Proposed maintainers will be approved via consensus of the Participants and with agreement of existing Maintainers, and should meet the following criteria: Proven experience in data modelling and/or software development in financial markets. In-depth understanding and proven track record of contribution to the CDM, as well as other data standards (such as ISO) and messaging protocols (such as FIX, FpML or Swift). 2.2.3 CDM Steering Working Group Decision Making: As outlined in governance.md , The CDM Steering Working Group will operate by consensus-based decision-making. Maintainers are responsible for determining and documenting when consensus has been reached. In the event a clear consensus is not reached, Maintainers may call for a simple majority vote of Participants to determine outcomes. 2.2.4 CDM Steering Working Group Appointment of the Editor(s): Editors will review and implement pull requests not expressed in code, test and release new functionalities, resolve bugs and implement approved improvements. CDM Design Principles ​ Contributions to the CDM have to comply with the following set of design principles that include the following concepts: Normalisation through abstraction of common components Composability where objects are composed and qualified from the bottom up Mapping to existing industry messaging formats Embedded logic to represent industry processes Modularisation into logical layers \ CDM development guidelines ​ The CDM Development Guidelines are defined by the Steering Working Group. The full set of CDM development guidelines can be found here . Version Management ​ The CDM is developed, built and released using standard software source-control management. Each new released version is announced to users via a release note that describes the change introduced by that new version. The CDM release history is available in the Release Section of the CDM documentation. Semantic Versioning ​ The CDM is released using the semantic versioning 2.0 system - See SemVer 2.0.0 . At high-level, the format of a version number is MAJOR.MINOR.PATCH (e.g. 1.23.456 ), where: A MAJOR ( 1 ) version may introduce backward-incompatible changes and will be used as high level release name (e.g. ""CDM Version 1""). A MINOR ( 23 ) version may introduce new features but in a backward-compatible way, for example supporting a new type of event or function. A PATCH ( 456 ) version is for backward-compatible bug fixes, for example fixing the logic of a condition. In addition, pre-release versions of a major release will be denoted with a DEV tag as follows: MAJOR.0.0-DEV.x (e.g. 1.0.0-DEV.789 ), where x gets incremented with each new pre-release version until it becomes the MAJOR.0.0 release. The minor, patch and pre-release numbers may sometimes increment by more than one unit. This is because release candidates may be created but not immediately released. Subsequently, a version associated with the next incremental unit may be released that includes the changes from the earlier release candidate. Unless under exceptional circumstances, the major number will be incremented by one unit only. Backward Compatibility ​ Like other types of software, backward compatibility in the context of a domain model means that an implementor of that model would not have to make any change to update to such version. Prohibited changes: Change to the structure (e.g. the attributes of a data type or the inputs of a function) or removal of any model element Change to the name of any model element (e.g. types, attributes, enums, functions or reporting rules) Change to any condition or cardinality constraint that makes validation more restrictive Change to the DSL that results in any existing expression becoming invalid Change to the DSL that results in change to any of the generated code's public interfaces Allowed changes: Change that relaxes any condition or cardinality constraint Change to any synonym that improves, or at least does not degrade, the mapping coverage Addition of new examples or test packs Change to the user documentation or model descriptions Addition of new data types, optional attributes, enumerations, rules or functions that do not impact current functionality Exceptions to backward compatibility may be granted for emergency bug fixes following decision from the relevant governance body. Version Availability ​ Several versions of the CDM will be made available concurrently, with a dual objective. The latest development version (i.e. with a pre-release tag) fosters continued, rapid change development and involves model contributions made by the industry community. Changes that break backward compatibility are allowed. This development version is available in read-only and read-write access on the CDM's modelling-platforms. The latest production version (i.e. without any pre-release tag) offers a stable, well-supported production environment for consumers of the model. Unless under exceptional circumstances, no new disruptive feature shall be introduced, mostly bug fixes only. Any change shall adhere to a strict governance process as it must be backward-compatible. Generally, it can only be developed by a CDM Maintainer. This production version is available in read-only access through the CDM's modelling-platforms. Earlier production versions, when still supported, are also available in read-only access for industry members who are still implementing older versions of the model. Over time, those earlier production versions enter long-term support in which supportability will be degraded, until they eventually become unsupported. Example . Assume that the latest major release of the model is 5. The various versions available would be as follows: 5.0.0 and any subsequent 5.x would be the latest production version. Backward-compatibility to the initial 5.0.0 version would be maintained for any 5.x successor version. The latest 4.x and 3.x may also be supported, but 2.x could be under long-term support and 1.x unsupported altogether. 6.0.0-DEV.x would be the latest development version. It can, and will generally, contain changes that are not backward-compatible with version 5. Backward-compatibility between successive 6.0.0-DEV.x versions is also not assured. Once fully developed, version 6.0.0 can be tagged as a major release and becomes the new latest production version. Note: The above example is for illustration only and not indicative of actually supported CDM versions. Design Principles The purpose of this section is to detail the CDM design principles that any contribution to the CDM development must adhere to. The CDM supports the market objectives of standardisation via a set of design principles that include the following concepts: Normalisation through abstraction of common components, e.g. price or quantity Composability where objects are composed and qualified from the bottom up Mapping to existing industry messaging formats, e.g. FpML Embedded logic to represent industry processes, e.g. data validation or state-transition logic Modularisation into logical layers, using namespace organisation Normalisation ​ To achieve standardisation across products and asset classes, the CDM identifies logical components that fulfil the same function and normalises them, even when those components may be named and treated differently in the context of their respective markets. By helping to remove inefficiencies that siloed IT environments can create (e.g. different systems dealing with cash, listed, financing and derivative trades make it harder to manage aggregated positions), such design reaffirms the goal of creating an inter-operable ecosystem for the processing of transactions across asset classes. An example of this approach is the normalisation of the concepts of quantity , price and party in the representation of financial transactions. The CDM identifies that, regardless of the asset class or product type, a financial transaction always involves two counterparties trading (i.e. buying or selling) a certain financial product in a specific quantity and at a specific price. Both quantity and price are themselves a type of measure , i.e. an amount expressed in a specific unit which could be a currency, a number of shares or barrels, etc. An exchange rate between currencies, or an interest rate, also fit that description and are represented as prices. This approach means that a single logical concept such as quantity represents concepts that may be named and captured differently across markets: e.g. notional or principal amount etc. This in turn allows to normalise processes that depend on this concept: for instance, how to perform an allocation (essentially a split of the quantity of a transaction into several sub-transactions) or an unwind, instead of specialised IT systems handling it differently for each asset class. It is imperative that any request to add new model components or extend existing ones is analysed against existing components to find patterns that should be factored into common components and avoid specialising the model according to each use case. For instance, in the model for averaging options (often used for commodity products, whereby multiple price observations are averaged through time to be compared to the option's strike price), the components are built and named such that they can be re-used across asset classes. Composability ​ To ensure re-usability across different markets, the CDM is designed as a composable model whereby financial objects can be constructed bottom-up based on building-block components. A composable and modular approach allows for a streamlined model to address a broad scope of operational processes consistently across firms' front-to-back flows and across asset classes. The main groups of composable components are: Financial products : e.g. the same option component is re-used to describe option payouts across any asset class, rather than having specialised Swaption , Equity Option or FX option etc. components. Business events that occur throughout the transaction lifecycle are described by composing more fundamental building blocks called primitive events : e.g. a partial novation is described by combining a quantity change primitive event (describing the partial unwind of the transaction being novated away) and a contract formation primitive event (describing the new contract with the novation party). Legal agreements that document the legal obligations that parties enter into when transacting in financial products are constructed using election components associated to functional logic that is re-usable across different types of agreement: e.g. the same logic defining the calculation of margin requirements can be re-used across both initial and variation margin agreements. In this paradigm, the type of object defined by the CDM, whether a financial product, business event or legal agreement, is not declared upfront: instead, the type is inferred through some business logic applied onto its constituents, which may be context-specific based on a given taxonomy (e.g. a product classification). The benefit of this approach is that consistency of object classification is achieved through how those objects are populated , rather than depending on each market participant's implementation to use the same naming convention. This approach also avoids the model relying on specific taxonomies, labels or identifiers to function and provides the flexibility to maintain multiple values from different taxonomies and identifier sets as data in the model related to the same transaction. This has a number of useful application, not least for regulatory purposes. Mapping ​ To facilitate adoption by market participants, the CDM is made compatible with existing industry messaging formats. This means that the CDM does not need to be implemented ""wholesale"" as a replacement to existing messaging systems or databases but can coexist alongside existing systems, with a translation layer. In fact, the CDM is designed to provide only a logical model but does not prescribe any physical data format, neither for storage nor transport. This means that translation to those physical data formats is built-in, and the CDM is best thought of as a logical layer supporting inter-operability between them. Note: Although the CDM features a serialisation mechanism (currently in JSON), this format is only provided for the convenience of representing physical CDM objects and is not designed as a storage mechanism. The need for such inter-operability is illustrated by a typical trade flow, as it exists in derivatives: a trade may be executed using the pre-trade FIX protocol (with an FpML payload representing the product), confirmed electronically using FpML as the contract representation, and reported to a Trade Repository under the ISO 20022 format. What the CDM provides is a consistent logical layer that allows to articulate the different components of that front-to-back flow. In practice, mapping to existing formats is supported by synonym mappings, which are a compact description in the CDM of how data attributes in one format map to model components. In turn, those synonym mappings can support an ingestion process that consumes physical data messages and converts them into CDM objects. The CDM recognises certain formats as de-facto standards that are widely used to exchange information between market participants. Their synonym mappings are included and rigorously tested in each CDM release, allowing firms that already use such standards to bootstrap their CDM implementation. Besides, because most standard messaging formats are typically extended and customised by each market participants (e.g. FpML or FIX), the CDM allows the synonym representation for those standards to be similarly inherited and extended to cover each firm's specific customisation. Embedded logic ​ The CDM is designed to lay the foundation for the standardisation, automation and inter-operability of industry processes . Industry processes represent events and actions that occur through the transaction's lifecycle, from negotiating a legal agreement to allocating a block-trade, calculating settlement amounts or exchanging margin requirements. While FINOS defines the protocols for industry processes in its documentation library, differences in the implementation minutia may cause operational friction between market participants. Even the protocols that have a native digital representation have written specifications which require further manual coding in order to result in a complete executable solution: e.g. the validation rules in FpML, the Recommended Practices/Guidelines in FIX or CRIF for SIMM and FRTB, which are only available in the form of PDF documents. Traditional implementation of a technical standard distributed in prose comes with the risk of misinterpretation and error. The process is duplicated across each firm adopting the standard, ultimately adding up to high implementation costs across the industry. By contrast, the CDM provides a fully specified processing model that translates the technical standards supporting industry processes into a machine-readable and machine-executable format. Systematically providing the domain model as executable code vastly reduces implementation effort and virtually eliminates the risk of inconsistency. For instance, the CDM is designed to provide a fully functional event model, where the state-transition logic for all potential transaction lifecycle events is being specified and distributed as executable code. Another CDM feature is that each model component is associated with data validation constraints to ensure that data is being validated at the point of creation, and this validation logic is distributed alongside the model itself. Modularisation ​ The set of files that define the CDM data structures and functions are organised into a hierarchy of namespaces . The first level in the namespace hierarchy corresponds to the layer of the CDM that the components belong to, and those CDM layers are organised from inner- to outer-most as follows: Namespaces have many benefits: Accelerated understanding of the model by allowing users to easily see a high-level view of the model and easily find, select, and study specific areas of interest Faster and easier to find data types and functions for referencing/use in new components Allowing for partial adoption of areas of interest in the model Smaller upgrades representing new versions limited to the name spaces that are impacted Each of these higher-level namespaces is further divided into lower-level namespaces. The independent components in each namespace are organised according to their core purpose but can be referenced from anywhere in the model to allow all the components to work together for a complete modelling solution. E.g. below is the product namespace: When developing new CDM components, the positioning of those components in the namespace hierarchy is critical as part of the design (or potentially the re-organising of the hierarchy following the new development), to ensure the CDM remains well organised. Agile Development Approach ​ The on-going development of the CDM adheres to a methodology inspired by the Agile software development framework. This methodology is based on two high-level principles: Focus on business value from the user's perspective, encapsulated in the concept of user story Delivery of small, releasable changes that contribute to that business value (sometimes referred to as shippable increments ) - i.e. no ""big bang"" changes Development by the CDM Maintainer team is being planned along a series of 2-week sprints aligned onto the CDM Architecture and Review Committee cycle. This development is guided by high-level priorities set on a quarterly basis. Outside contributions that are proposed by industry members, whilst not formally enlisted in the sprint process, usually generate additional tasks (design, review, deployment etc.) for the CDM Maintainer team that will need to be included in a sprint. Those outside contributions still need to comply with the above development principles to ensure a smooth integration with the rest of the development by the CDM Maintainer team. Focus on business value ​ Any CDM development work must start from a business case describing the business benefit being sought from the proposed development, as seen from the perspective of the user who will enjoy that benefit. This is know as a user story in the agile framework. What a user story looks like ​ A good user story comprises three elements which can be summarised into one sentence: who, what and why. Who defines the user (or more generally the set of users defined by some profiling) that will enjoy that benefit What defines the feature to be delivered, as a verbal proposition applying to the user - i.e. ""the user can do this or that"" Why specifies the benefit, i.e. what makes this feature important for the user Since a story is from the user's perspective, it must be written in plain language, or at least in language that is intelligible by that user. It must be free of technical jargon that only the developer of that feature may understand, so that it can be communicated to the user. Further details about the business case (including documents, pictures, sample data etc.) may be attached to a user story to complement that summary, but the sumamry itself should be whole and self-explanatory. Story vs task ​ By contrast, how a story gets delivered is not part of that story: How describes the set of tasks that will need to be executed to deliver the story. This is where the story is being decomposed into units of work written in terms that are actionable by the developers. Tasks will typically map to steps in the software development lifecycle: analysis, design, build, test, deploy. They must be planned before the story is scheduled for development, as part of the sprint planning process. Based on this planning, a set of stories is being prioritised for development in the upcoming sprint. Those stories are communicated to users at the Architecture and Review Committee, but not their underlying tasks or techical details. Some examples ​ Instead of writing: ""Commodity Swap Follow Up w/Enum values, mapping, samples"" Which is unclear, assumes some context which not all users may have (""follow-up"" from what?) and has no explicit benefit, write: ""A Commodity user of the CDM can map a set of basic Commodity attributes to represent simple Commodity derivative products."" In which some of the underlying tasks may be: ""Map basic Commodity enumerations"" ""Add Commodity samples to the ingestion test pack"" etc. As a rule, a task is written in the imperative mode as an injunction to the developer, whereas a story should be written as a sentence starting with the user's profile as the subject of a verbal proposition. A story written in the imperative mode is more likely a task and improperly written. For instance, instead of writing: ""Release member contribution for DayCountFraction."" Write: ""A user of interest rate products is able to model products that use the ACT/364 day count convention in the CDM."" Where the ""Release"" injunction is attached to a deploy-type task. Delivery of small releasable units ​ What is a releasable unit ​ To maintain on-going momentum in the development of the CDM, delivery is organised around small but releasable units of change. This means that any change must be small enough to be achievable during a single sprint (usually), but large enough to be releasable as a cohesive whole. In particular, a change unit should not be regressive or break existing functionality, even if only temporarily (except when retiring such functionality is the purpose of that change) - in agile terms, it must be shippable . This principle applies to on-going development by the CDM Maintainers as well as to outside contributions. The CDM development approach aligns the concepts of user story and releasable unit , therefore stories should be calibrated to be achievable during a single sprint. 1 contribution = 1 releasable unit = 1 user story Note: A CDM release may contain more than 1 releasable unit. Every unit should still be shippable in isolation, even if they may end-up being shipped as a group. Epics ​ Some larger changes may not be achievable in a single sprint: e.g. if they impact a large number of objects or core features of the model. Such changes are known as epics and need to be decomposed into several user stories. Developers or contributors are responsible for ensuring that the changes are being delivered in small, incremental units and must plan accordingly. Particularly for complex stories, not all of that story's tasks may necessarily be known in advance and therefore guaranteed to fit in one single sprint. A story may demand some prior analysis before it can be decomposed into development tasks. It may also require several design iterations before development can start. Those prior discovery tasks should be fit into a single sprint and the actual development scheduled in a subsequent sprint. The discovery phase may reveal that the story is not well calibrated and is in fact an epic that should be further decomposed. This is an acceptable scenario which does not contravene the prescribed development approach, as long as development has not yet started. In that case the story should be requalified and several stories be spun-out as a result, before development can start. How to Contribute The purpose of this section is to provide guidance for submitting, reviewing and releasing changes to the CDM contributed by the wider industry community including market participants, trade associations and technology or service vendors. It describes: What a Contributor should do to edit and contribute changes to the CDM What a Maintainer should do to review the changes How to release a new CDM version once changes have been approved ::: {#modelling-platforms} Development of the CDM is supported through various modelling platforms, including Rosetta and Legend . Regardless of the modelling platform used, modelling and contribution to the CDM should go through the contribution check-list below. The steps required to change the CDM are aligned with the software development lifecycle typically applicable to the development of any other software. This development lifecycle is illustrated in the diagram below. Each step is associated to the relevant component of the Rosetta platform that can be used to support the development of the CDM. Note: This documentation is not an endorsement of any modelling platform and associated products and CDM users remain invited to leverage the tools of their choosing. This contribution guide has been contextualised with references to Rosetta to ease understanding and align with the current process. Before you start modelling ​ Before you start modelling, please make sure you have gone through the following pre-modelling checklist: Review the design-principles and governance Review the Rosetta Starter Guide or equivalent in your chosen modelling platform. In addition, for large model changes or changes to core data types, it is recommended that the Contributor reviews the agile-development-approach and follows these steps: Define use case . Identify and document one or more use cases with details (e.g. a sample trade). Draft conceptual design (high level). Draft a conceptual view showing the set of data types, their definitions (and/or sample attributes but not the whole set of attributes), their relationships to each other, and, if applicable, a workflow. Design approval . Obtain approval of high-level conceptual design from CDM stakeholders: CDM Owners (FINOS and other involved Trade Associations, where applicable) CDM Sub-Working Group, if applicable CDM Architecture and Review Committee Quality assurance . Seek the early appointment of at least one CDM Maintainer who can assist modelling discussions and provide early feedback. CDM Maintainers are appointed by the CDM Owners as and when relevant. Please contact cdm@lists.finos.org . Note: Unless explicitly instructed by a CDM Maintainer, a Contributor can only ever develop changes to a development (i.e. pre-release) version of the CDM. Editing the model ​ When editing the CDM, please go through the following modelling checklist: CDM version: use the latest available development version Syntax: no syntax warnings or errors Compilation: model compiles ok with no static compilation errors Testing: all translate regression tests expectations for mapping, validation and qualification maintained or improved. Additional test samples may be needed if use-case is not covered by existing samples. Namespace: all model components positioned in the correct namespace Descriptions: all model components have descriptions The following sections detail that checklist. When using the Rosetta Design web application to edit the model, the Contributor should also refer to the Rosetta Design Guide . CDM version ​ To the extent possible it is recommended that the Contributor keeps working with a version of the CDM that is as close as possible to the latest to minimise the risk of backward compatibility. Please refer to the Source Control Integration Guide for more information. Syntax ​ The model is represented in the Rosetta DSL syntax. All syntax warnings and errors must be resolved to have a valid model before contributing any changes. For further guidance about features of the syntax, please refer to the Rosetta DSL Documentation . In Rosetta Design, that syntax is automatically checked live as the user edits the model, as described in the Rosetta Design Content Assist Guide . Compilation ​ Normally, once the model is syntactically correctly edited, valid code is being auto-generated and compiled. However, certain model changes can cause compilation errors when changes conflict with static code (e.g. certain mapper implementations). The Rosetta support team can help resolve these errors before the changes are contributed. In most cases you will be able to contact the team via the In-App chat . If the support team identifies that significant work may be required to resolve these errors, they will notify the Contributor who should then contact the CDM Maintainer originally appointed for the proposed change and/or CDM Owners. The latter will be able to assist in the resolution of the issues. For more information about auto-compilation using the Rosetta DSL, please refer to the Rosetta Auto Compilation Guide . Testing ​ The CDM has adopted a test-driven development approach that maps model components to existing sample data (e.g., FpML documents or other existing standards). Mappings are specified in the CDM using synonym which are collected into a Translation Dictionary, and the sample data are collected into a Test Pack. Each new model version is regression-tested using those mappings to translate the sample data in the Test Pack and then comparing against the expected number of mapped data points, validation and qualification results. When using Rosetta to edit the model, contributors are invited to test their model changes live against the Test Pack using the Rosetta Translate application, referring to the Rosetta Translate Guide . When editing existing model components, the corresponding synonyms should be updated to maintain or improve existing mapping levels. When adding new model components, new sample data and corresponding synonym mappings should also be provided so the new use-case can be added to the set of regression tests. Please refer to the Mapping Guide for details about the synonym mapping syntax. Namespace ​ All model components should be positioned appropriately in the existing namespace hierarchy. If the proposed contribution includes changes to the namespace hierarchy, those changes should be justified and documented. Any new namespace should have an associated description, and be imported where required. Please refer to the namespace-documentation section for more details. Descriptions ​ All model components (e.g. types, attributes, conditions, functions etc.) should be specified with descriptions in accordance with the CDM Documentation Style Guide . Contributing model changes ​ Contribution checklist ​ Before you start contributing your model changes, please go through the following contribution checklist: Specify a meaningful title and description for the contribution Notify the CDM Maintainers (via email or Slack) of the submitted contribution Include: Any notes on expected mapping, validation or qualification changes (success numbers should not decrease) Additional data samples, if necessary Documentation adjustment, if necessary Release notes Any other additional materials or documentation that may help with the review and approval process Note: A contribution should be a whole releasable unit and its size calibrated in accordance with the CDM's agile development approach . Contributing ​ Changes are contributed by submitting a Pull Request for review into the CDM source-control repository. This pull request will invoke a build process to compile and run all CDM unit tests and regression tests. Given the alignment: 1 pull request = 1 contribution = 1 releasable unit = 1 user story, we recommend labelling the pull request with the user story label, i.e. ""STORY-XYZ: ..."" to facilitate its tracking. Note: All contributions are submitted as candidate changes to be incorporated under the CDM licence . When using Rosetta to contribute model changes, the contribution interface allows to specify a title and description for the contribution. Those inputs are used to create a Pull Request on a one-off branch in the source-control repository. Please refer to the Rosetta Workspace Contribution Guide for more information. Note: It is not yet possible to contribute updated test expectations, documentation, release notes or new sample data using Rosetta, so these must be provided to the CDM Maintainers via Slack or email. Documentation ​ The CDM documentation must be kept up-to-date with the model in production. Where applicable, the Contributor should provide accompanying documentation (in text format) that can be added to the CDM documentation for their proposed changes. The documentation includes code snippets that directly illustrate explanations about certain model components, and those snippets are validated against the actual model definitions. When a model change impacts those snippets, or if new relevant snippets should be added to support the documentation, those snippets should be provided together with the documentation update. Release note ​ A release note should be provided with the proposed model change that concisely describes the high-level conceptual design, model changes and how to review. Please refer to the content-of-release-notes for further guidance on editing release notes. Reviewing model changes ​ Review checklist ​ Before starting to review a contribution, the CDM Maintainer should go through the following review checklist: Review Pull Request to assert that: Model changes fulfil the proposed design and use-case requirements Synonyms have been updated and output (JSON) looks correct Contributed model version is not stale and does not conflict with any recent changes Changes are in accordance with the CDM governance guidelines Note: It is not yet possible to verify that mapping, validation and qualification expectations have been maintained by looking at the output of the Pull Request and CDM build only. Please refer to the downstream-dependencies section for more details. CDM build process completed with no errors or test failures Review additional samples provided (if use-case is not covered by existing samples) All model components positioned in the correct namespace All model components have descriptions Additional documentation provided, if necessary. Release note provided Any review feedback should be sent to the Contributor as required via Slack, email or in direct meetings. Note: Depending on the size, complexity or impact of a contribution, the CDM Maintainer can recommend for the contribution to be presented with an appropriate level of details with the CDM Architecture and Review Committee for further feedback. The CDM Maintainer will work with the Contributor to orchestrate that additional step. The additional feedback may recommend revisions to the proposed changes. When it is the case the review process will iterate on the revised proposal. Model maintenance ​ Before the Pull Request can be merged into the CDM's main branch, some work is usually required by the Maintainer to preserve the integrity of the model source code and of its downstream dependencies. Post-review technical tasks ​ A number of technical tasks may need to be performed on the Pull Request once it is approved: Stale CDM version : Contribution is based on an old CDM version and model changes conflict with more recent changes. If the conflicting change is available in Rosetta, the contributor should be asked to update their contribution to the latest version and resubmit. If the conflicting change is not yet available in Rosetta, this merge will need to be handled by the CDM Maintainer. Failed unit tests : Java unit tests in the CDM project may fail due to problems in the contributed changes. Alternatively it may be that the test expectations need to be updated. The Maintainer should determine the cause of the test failure and notify either the Contributor or work on adjusting the test expectations. Additional documentation : If the contributor provided additional documentation, the Maintainer should update the CDM documentation by editing the documentation.rst file in GitHub. Documentation code snippets : To avoid stale documentation, the CDM build process verifies that any code snippets in the documentation exists and is in line with the model itself. The Maintainer should adjust or include any code snippets by editing the documentation.rst file on GitHub. Code generation : Model changes may cause code generator failures (e.g., Java, C#, Scala, Kotlin etc.). In the unlikely event of code generation failures, these will need to be addressed by the Maintainer. Downstream dependencies ​ The CDM has a number of dependent projects that are required for the model to be successfully distributed. It is possible that model changes may cause these downstream projects to fail. The Maintainer will need to test and, if necessary, update those before the changes can be released. Translate : The regression tests in this project compare the contributed model against the expected number of mapping, validation and qualification results. Due to the contributed model changes, it is likely that there will be expectation mismatches that cause this build to fail. CDM Homepage : compile and test. CDM Java Examples : compile and test. Note: In most cases, the post-review technical tasks and downstream dependencies require software engineering expertise in addition to CDM expertise. Additional technical support from the CDM Maintainer team may need to be called upon to address those. The change can be merged into the main CDM code base only upon: approval by CDM Maintainers and/or CDM Architecture and Review Committee, successful completion of all the above technical tasks, and successful builds of the CDM and all its downstream dependencies. Releasing model changes ​ Once the contributed model change has been merged, a new release can be built, tested and deployed. The Maintainer will work with the CDM Owners and the Contributor on a deployment timeline. The following release checklist should be verified before deploying a new model: Update the CDM version number, using the semantic versioning format Build release candidate, and test Build documentation website release candidate, and test Deploy release candidate and notify channels if need be (Currently done at a later stage) Update the latest CDM version available in Rosetta Note: When the release process is handled through Rosetta Deploy, the Maintainer should contact the Rosetta support team to request that deployment and discuss a timeline for the release. Documentation Style Guide ​ The purpose of this section is to provide form and substance recommendations for editors of CDM documentation. ""Documentation"" in this context means any form of written guidance to CDM users and includes: the CDM user documentation release notes provided with each CDM release any description developed in the logical model itself, which includes: data types and attributes enumerations functions and rules test descriptions any other areas of the logical model where a textual description may be provided The intended audience for the CDM documentation includes software developers, data modelers, legal experts, business experts, and other subject matter experts who may have expertise in one area related to financial products, but are not experts in every area. The baseline for the recommendation is standards for spelling, punctuation, and other style rules applicable to British English. The recommendation in this document extends this rule set with a set of guidelines applicable to documentation for logical models. The recommendation does not provide an exhaustive list of all of the standard British English rules, but provides selective examples that are common to documentation in general. Writing and editing style is subjective and a matter of personal preferences, rather than right or wrong. The following guidelines are intended to ensure that the documentation provides consistent styling, regardless of who writes it, but should not be interpreted as an authoritative source on ""good"" styling. Unless otherwise noted, the recommended rules apply to all forms of CDM documentation. When rules are applicable only to certain forms of documentation (for instance, the logical model descriptions or the release notes), they will be specified as such. Terminology ​ The CDM ​ The model should be referred to as the CDM , without any ownership mention. The only exception is the Overview of the FINOS CDM section at the beginning of the user documentation when the CDM is introduced as the FINOS CDM . General data definition components ​ The two data definition components should be referred to as follows: Data type : defines an entity with a description, attributes, and where applicable, conditions. Not type . Not class : although these are appropriate terms for some of the distributions of the CDM into other languages, they are not applicable for all. Attribute : defines a member of a data type. Not field . Not element . Product ​ Financial Product . The user documentation defines financial-product as the highest level of the hierarchy of the universe of products. The term Financial Product should be used consistently throughout the documentation and wherever applicable in the model descriptions when describing the broad set of products. Contractual Product . Similarly, contractual-product is defined as a subset of Financial Products and should be used consistently in any documentation. Not Derivatives . Not OTC . Contractual Product is at a higher hierarchy level than OTC Derivatives because it can include other types of products such as Security Financing. Event ​ Business Event . In the CDM, a business-event represents an event that may occur during the lifecycle of a trade, such as an amendment, a termination, a reset or a payment. Not Lifecycle Event . the term Business Event should be consistently used when referring to these data structures in the CDM documentation. Primitive Event . In the CDM, a primitive-event represents a building block component used to specify business events in the CDM. Not Primitive (stand-alone). In the CDM documentation, the word Primitive always needs to be qualified with Event , because the word Primitive may be associated to very different meanings, e.g. in computing. Completeness ​ User Documentation ​ The user documentation should provide an applicable introduction and should have a section for every primary component of the CDM. Each section should provide enough business context and explanations of the model so that the average reader in the target audience understands the purpose of the component and its role in the model. Each section should have at least one example of a data structure Logical Model ​ Every data type, attribute, enumerated value, function, and test should have a description that describes its purpose in the context of the CDM. Accuracy ​ Descriptions should accurately describe the current state of the model. This seems obvious, but there are many possible ways for introducing misalignments, including: an anticipated change never occurred, or the author incorrectly interpreted the structure, or the data structure changed while the documentation or description was not updated. Subtasks in a design process should include an assessment of documentation and descriptions that will be required to be changed or created, and should include the content. A release checklist should verify that the affected documentation and descriptions are completed accordingly. Content Guidelines ​ General guidelines ​ Data Definition components (e.g. data types, attributes, enumerations and enumerated values) should be explained in business terms. The description of objects in the model should begin with the purpose of the object. The purpose should explain what the object is, not ""what it is not"". Data type description should begin with a verb that describes what the type does. The logical model identifies data types without needing a description, therefore, the description should not begin with a phrase like: ""A data type that does..."" Attribute description should articulate the use of the type in the context of the attribute. The description should not be tautological, e.g. PartyRole \<defines the party role > is not compliant with these guidelines. References to a similar attribute in FpML should not be used as a crutch in place of explaining a data type, attribute, etc. In most cases, where a reference to FpML is considered useful, it should be placed at the end of a description in the logical model, or in a note at the end of a section in the user documentation. In the case of the logical model, note that synonyms for FpML are provided, therefore it should not be necessary to reference FpML in every case. Example of a non-compliant description: <""A data type to represent a financial product. With respect to contractual products, this class specifies the pre-execution product characteristics (the ContractualProduct class). This class is used as underlying for the option exercise representation, which makes use of the contractualProduct attribute to support the swaption use case, with the exercise into a swap. In a complete workflow, the swaption contract itself then needs to be superseded by a swap contract underpinned by the exercised swap as a contractualProduct.""> Instead a compliant description would state: <""Represents a financial product. With respect to a contractual products, this data type specifies the pre-execution product characteristics...”> Another non-compliant example: <""This class corresponds to the FpML CalculationAgent.model.""> The description of data objects or the overall model should be focused on the current state, there should be no reference to the history of the model or a future state. The history of the model is not relevant in this context. It is sufficient to describe how the model currently works. Forward-looking statements can create a perception that the product is not finished, and become a distraction to explaining what the product does. Moreover, these future plans may never materialise. Given these rules, phrases such as ""the model currently does...."" should be excluded because any documentation must be a description of what the model currently does. Heading styles and flow in the user documentation ​ Heading styles. The user documentation is edited in the RST (reStructured Text) mark-up language, which is then rendered into Html in the CDM documentation website using Sphinx . For headings to be rendered with the correct structure, they should be annotated according to the following table: If using a header to identify a section to describe a component, then use headers to describe other components that are at the same level. Sub-headings should have a name distinct from the higher level heading. e.g. if Legal Agreement is the Heading Level 2, then there should not be a heading at level 3 or 4 with the exact same title. Heading Level Notation (underline in .rst) Relative font size (as seen by users) Section Example 1 [===============] XL font and bold common-domain-model 2 [- - - - - - - - - - - - - - -] L font and bold product-model-page , legal-agreements-page 3 [\^\^\^\^\^\^\^\^\^\^\^\^\^\^\^] M font and bold tradable-product 4 [""""""""""""""""""""""""""""""] S font (same ascontent), but bold price-quantity :Heading Styles The RST editing syntax in which the user documentation is written is a standard web mark-up language, for which a reference guide can be found at: https://sublime-and-sphinx-guide.readthedocs.io Logical organization and order: The user documentation should walk the user through the model from the top down, beginning at a description of the primary components. Levels 1 and 2 should include a bullet point list of the sub sections that will be described (bullets formatted with the insertion of an asterisk followed by a space). Define business terms and CDM terminology early in a section so that the broader audience understands the model. Details about a topic should be presented in the section for that topic: In the case of a model component, the description of the component should always be followed by an example. Most or all of the explanation should occur before the example, not after, unless the example was needed as context for an explanation. Transitions from one topic to another should be used to help guide the user through the model. Content of Release Notes ​ Release notes are text describing the content of any new CDM release and are a critical component of the distribution of that release. Release notes are edited in the Mark-Down (MD) syntax, which is then rendered into Html in the various channels where the release is published. Release notes should begin with a high-level headline of the part of the model being changed, followed by ""--"" and a short headline description For example: ""# Legal Agreement Model - Collateral Agreement Elections"" They should provide enough detail for a reviewer or other interested parties to be able to find and evaluate the change. For a data model change, for example, the data type and attributes should be named and the before/after states of the model explained, along with a justification in which the issue is summarised. They should also embed a link to the Pull Request containing the change, to enable users to inspect those changes in details. If the release notes describe mapping rules, there should be explicit information about the examples affected and the change in resulting values for those examples. If the release is documentation, it should specify exactly where the document was changed and why. Special formatting rules related to use of the MD mark-up language: Headline should begin with a # , as in the above example, so that it appears correctly formatted in Html * before and after text (no space) for bold _ before and after text (no space) for italics – (plus a space) for bullets Backticks ` \ before and after model components, e.g. data types, attributes, enums, function names, etc. for special code-style formatting Example release notes formatted in MD: # *CDM Model: Expanded set of enumerations in RegulatoryRegimeEnum* _What is being released_ Additional regimes have been added to the `RegulatoryRegimeEnum` which is used to express the required regimes for initial margin documentation. The `RegulatoryRegimeEnum` is used as an enumeration for attributes in the `ApplicableRegime` and `SubstitutedRegime` data types within the legal agreements model. The new enumerated values are `BrazilMarginRules`, `UnitedKingdomMarginRules`, `SouthAfricaMarginRules`, `SouthKoreaMarginRules`, and `HongKongSFCMarginRules`, all of which have come into force in January 2021.  Each of these enumerated values has a complete description that uses the text provided in the relevant regulatory supplement. _Review directions_ In the CDM Portal select the Textual Browser, search for ‘ApplicableRegime’ and ‘SubstitutedRegime’, click on the ‘RegulatoryRegimeEnum’ next to the ‘regime’ attribute and observe the expanded list of regimes, including the ones noted above. Inspect Pull Request: [#1101](https://github.com/finos/common-domain-model/pull/1101) The MD editing syntax in which release notes are written is a standard web mark-up language, for which a reference guide can be found at: https://www.markdownguide.org/cheat-sheet/ Note: The MD syntax provides similar features to the RST syntax (used to edit the user documentation), but the special formatting characters are slightly different between the two. While RST allows richer features that are useful for a full documentation website, MD is preferred for release notes because Slack supports (a subset of) the MD language and can therefore serve as a release publication channel. Style ​ Content style ​ Content should be correct with regard to grammar, punctuation, and spelling (in British English), including but not limited to the following rules: Grammatical agreement, e.g. data types need, not data types needs Punctuation: etc. requires a period. Complete sentences should end with a period or colon (there should be no need for a question mark or exclamation point in these artefacts). Incomplete sentences cannot end with a punctuation. For example, ""Through the legalAgreement attribute the CDM provides support for implementors to:"" is an incomplete sentence and cannot end in a punctuation. This can be fixed by adding a few words, e .g. ""Through the legalAgreement attribute the CDM provides support for implementors to do the following:"" Always use the Oxford Comma (aka the Serial Comma) for clarity when listing more than two items in a sentence, e.g. ""data types, attributes, and enumerated values."" In extreme cases, failure to use this comma could be costly. Other grammatical rules Agreement of numbers: For example, if one sentence reads ""the following initiatives..."" , then it should be followed by more than one. Sentences should not end with a preposition Non-compliant example: ""..to represent the party that the election terms are being defined for."" Compliant: ""...to represent the party or parties for which the election terms are being defined."" When a name or phrase is defined - continue to use it unless an alias has been defined. For example, one section reviewed had an expression ""agreement specification details"" but then switched to using ""agreement content"" without explanation. There is sufficient terminology to absorb, as such there is no need for synonyms or aliases, unless there are commonly used terms, in which case, they should be defined and one term should be used consistently. User Documentation and descriptions should always be in the third person, for example: ""the CDM model provides the following..."". Never use the first person (including the use of ""we""). In the user documentation, when there is a need for a long list, use bullets ( * or - followed by space, then text) as opposed to long sentences. To the extent possible, use simple direct sentence structures, e.g. replace ""An example of such"" with ""For example"", or replace ""Proposals for amendment to the CDM can be created upon the initiative of members of a Committee or by any users of CDM within the community who are not a current Committee member."" with ""Committee members or any user of CDM within the community can propose amendments to the CDM."" Exclude the usage of ""mean to"", ""intends to"", or ""looks to"". For example, ""the model looks to use strong data type attributes such as numbers, boolean or enumerations whenever possible."" Either the object works as designed or it does not. This expression might be used in a bug report when describing a function not working as intended but not to describe a production data model. Explain the CDM objects in an honest and transparent manner, but without criticism of the model. Sentences such as: ""...which firms may deem inappropriate and may replace by..."" or ""the model is incomplete with regards to..."" are unnecessary in a documentation. Rather, issues which may be identified in the CDM should be raised and addressed via the CDM governance structure. Special format for CDM objects ​ Data types and attributes display rules: Data types and attributes should be identified in the editor with code quotes, where the text between the quotes will appear in a special block format as illustrated here: LegalAgreementBase . If the same word or phrase is used in a business context, as part of an explanation, then the words should be spaced and titled normally and the special format is not required: e.g. ""Tradable products are represented by..."". Code snippets should be preceded by the string: .. code-block:: Language (where the Language could be any of Haskell, Java, JSON, etc.), followed by a line spacing before the snippet itself. The entire snippet should be indented with one space, to be identified as part of the code block and formatted appropriately. Indentation can be produced inside the snippet itself using further double space. Meta-data such as data type descriptions or synonyms that appear in the CDM should be excluded from the code snippet, unless the purpose of the snippet is to illustrate those. Example of how a code snippet should be edited in the documentation: .. code-block:: Haskell type Party: [metadata key] partyId PartyIdentifier (1..*) name string (0..1) [metadata scheme] businessUnit BusinessUnit (0..*) person NaturalPerson (0..*) personRole NaturalPersonRole (0..*) account Account (0..1) contactInformation ContactInformation (0..1) And the result will be rendered as: type Party: [metadata key] partyId PartyIdentifier (1..*) name string (0..1) [metadata scheme] businessUnit BusinessUnit (0..*) person NaturalPerson (0..*) personRole NaturalPersonRole (0..*) account Account (0..1) contactInformation ContactInformation (0..1) Note: Code snippets that appear in the user documentation are being compared against actual CDM components during the CDM build process, and any mismatch will trigger an error in the build. This mechanism ensures that the user documentation is kept in sync with the model in production prior to any release. Fonts, Text Styles, and Spaces ​ Bold should be used sparingly: Only in the beginning of a section when there is a salient point to emphasize, like a tag line - the bold line should be syntactically complete and correct. In the editor, bold is specified with double asterisks before and after the word or phrase. Italics Italics should be used when defining an unusual term for the first time rather than using quotes, for example to identify something CDM specific, such as the concept of Primitive Events. In the editor, italics is specified with a single asterisk * before and after the word or phrase. Single space should be used in-between sentences, not double space. Style references for additional guidance ​ New Hart's Rules : An updated version of this erstwhile comprehensive style guide for writers and editors using British English, published by the Oxford University Press. Invaluable as an official reference on proofreading and copy-editing. Subjects include spelling, hyphenation, punctuation, capitalisation, languages, law, science, lists, and tables. An earlier version coined the phrase Oxford Comma in July 1905. Eats, Shoots & Leaves: The Zero Tolerance Approach to Punctuation : A light-hearted book with a serious purpose regarding common problems and correctness for using punctuation in the English language."
Get_Involved.txt,"Main Menu Get Involved Version: 5.13.0 On this page Get Involved Interact with the CDM community ​ GitHub ​ CDM activity primarily happens in this CDM GitHub repository . Watch the repository in order to be notified of new Pull Requests and issues. Email ​ If you'd like to receive official updates, please send an email to You can join the CDM mailing list by sending an email to cdm+subscribe@lists.finos.org . Meetings ​ Finally, another great way to interact with the community is to attend the bi-weekly Contribution Review Working Group , monthly Collateral Working Group , monthly FINOS  Structured Products Working Group , monthly Steering Working Group , monthly Technology Architecture Working Group , bi-weekly Derivative Products and Business Events Working Group , and/or quarterly Steering Working Group: email to be added to the meeting invites directly, or find the meeting in the . Need help? ​ Email if you need help getting started in the CDM Community or if you encounter technical difficulties accessing repositories, mailing lists or meetings. Contacting CDM Maintainers ​ FINOS CDM Maintainer Representing Capacity GithubID Gabriel Callsen ICMA OrgRep gabriel-ICMA Tom Healey ICMA OrgRep tomhealey-icma Vernon Alden-Smith ISDA OrgRep valdensmith Eleonora Acuna ISDA OrgRep eacunaISDA David Shone ISDA OrgRep dshoneisda Adrian Dale ISLA OrgRep ADaleISLA Chris Rayner ISLA OrgRep chrisisla Minesh Patel Regnosys OrgRep minesh-s-patel Leo Labeis Regnosys OrgRep lolabeis Hugo Hills Regnosys OrgRep hugohills-regnosys Lyteck Lynhiavu ISDA OrgRep llynhiavu Manuel Martos TradeHeader OrgRep manel-martos Marc Gratacos TradeHeader OrgRep mgratacos If you would like to get in touch with the CDM maintainer team, contact them through their mailing list at https://lists.finos.org/g/cdm-maintainers . You can do so by first subscribing at cdm-maintainers+subscribe@lists.finos.org and posting at cdm-maintainers@lists.finos.org ."
Demos.txt,"Main Menu Demos Version: 5.13.0 Demos Watch the demo from otc Digital entitled ""Integrated digital assets marketplace with full lifecycle and automation using CDM"" Marc Gratacos (Managing Partner at TradeHeader) delivered an amazing walkthrough on the Common Domain Model (CDM). Highly recommend to anyone who wants to start digging into CDM Watch the ISDA DRR CDM Training Sessions 27 March 2024 How to Get Started with CDM Meetup April 2024"
Product_Model.txt,"Main Menu Product Model Version: 5.13.0 On this page Product Model Where applicable, the CDM follows the data structure of the Financial Products Markup Language (FpML), which is widely used in the OTC Derivatives market. For example, the CDM type PayerReceiver is equivalent to the FpML PayerReceiver.model. Both of these are data structures used frequently throughout each respective model. In other cases, the CDM data structure is more normalised, per Development Guidelines. For example, price and quantity are represented in a single type, TradableProduct , which is shared by all products. Another example is the use of a composable product model whereby: Economic terms are specified by composition , For example, the InterestRatePayout type is a component used in the definition of any product with one or more interest rate legs (e.g. Interest Rate Swaps, Equity Swaps, and Credit Default Swaps). Product qualification is inferred from those economic terms rather than explicitly naming the product type, whereas FpML qualifies the product explcitly through the product substitution group. Regardless of whether the data structure is the same or different from FpML, the CDM includes defined Synonyms that map to FpML (and other models) and can be used for transformation purposes. More details on Synonyms are provided in the Mapping (Synonym) section of this document. TradableProduct ​ A tradable product represents a financial product that is ready to be traded, meaning that there is an agreed financial product, price, quantity, and other details necessary to complete an execution of a security or a negotiated contract between two counterparties. Tradable products are represented by the TradableProduct type. type TradableProduct: product Product (1..1) tradeLot TradeLot (1..*) counterparty Counterparty (2..2) ancillaryParty AncillaryParty (0..*) adjustment NotionalAdjustmentEnum (0..1) Note: The conditions for this data type are excluded from the snippet above for purposes of brevity. The primary set of attributes represented in the TradableProduct data type are ones that are shared by all trades and transactions. For example, every trade has a price, a quantity (treated jointly as a trade lot), and a pair of counterparties. In some cases, there are ancillary parties, or an allowable adjustment to the notional quantity. All of the other attributes required to describe a product are defined in distinct product data types. Counterparty ​ The counterparty attribute of a TradableProduct is constrained to be exactly of cardinality 2. The CDM enforces that a transaction can only occur between a pair of counterparties, with any other party involved in the transaction represented by the ancillaryParty attribute. The counterparty attribute uses the Counterparty data type, which links a specific Party object identifying that party to its role in the transaction. The counterparty roles in the CDM are normalised to be either Party1 or Party2 and captured as a pair of enumerated values. This design allows to use anonymised Party1 and Party2 values to specify the direction of flows in the definition of a tradable product without having to reference specific parties. This means that the same product can now be defined in a party-agnostic way and used to represent transactions between potentially many different parties. type Counterparty: role CounterpartyRoleEnum (1..1) partyReference Party (1..1) [metadata reference] enum CounterpartyRoleEnum: Party1 Party2 type Party: [metadata key] partyId PartyIdentifier (1..*) name string (0..1) [metadata scheme] businessUnit BusinessUnit (0..*) person NaturalPerson (0..*) personRole NaturalPersonRole (0..*) account Account (0..1) contactInformation ContactInformation (0..1) Note: The partyReference attribute in Counterparty is annotated with a [metadata reference] , which means that a reference to the party object can be passed in instead of a copy. In that case, the attribute's type must itself be annotated with a [metadata key] , so that it is referenceable via a key. The use of the key / reference mechanism is further detailed in the Rosetta DSL documentation. TradeLot ​ A trade lot represents the quantity and price at which a product is being traded. In certain markets, trading the same product with the same economics (except for price and quantity) and the same counterparty may be treated as a separate trade. Each trade is represented by a tradable product containing only 1 trade lot. In other markets, trading the same product with the same characteristics (except for price and quantity) is represented as part of the same trade. In this case, a single tradable product contains multiple trade lots represented as an array of the TradeLot data type. When a trade can have multiple trade lots, increases (or upsize) and decreases (or unwind) are treated differently. An increase adds a new TradeLot instance to the tradadable product, whereas a decrease reduces the quantity of one or more of the existing trade lots. Note: The term lot is borrowed from the Equity terminology that refers to each trade lot as a tax lot , where the capital gains tax that may arise upon unwind is calculated based on the price at which the lot was entered. For each trade lot, the quantity and price are represented by an attribute called priceQuantity . type TradeLot: lotIdentifier Identifier (0..*) priceQuantity PriceQuantity (1..*) The pricequantity attribute is represented as an array of the PriceQuantity data type. For composite financial products that are made of different legs, each leg may require its own price and quantity attributes, and each instance of a PriceQuantity data type identifies the relevant information for the leg of a trade. For example, for an Interest Rate Swap, a trade lot would have one instance of the PriceQuantity data type for each interest leg, and potentially a third one for an upfront fee. By comparison, the purchase or sale of a security or listed derivative would typically have a single PriceQuantity instance in the trade lot. PriceQuantity ​ The price and quantity attributes of a trade, or of a leg of a trade in the case of composite products, are part of a data type called PriceQuantity . This data type also contains (optionally): an observable, which describes the asset or reference index to which the price and quantity are related settlement terms and the buyer/seller direction, in case that price and quantity are meant to be settled a date, which indicates when these price and quantity become effective type PriceQuantity: [metadata key] price PriceSchedule (0..*) [metadata location] quantity NonNegativeQuantitySchedule (0..*) [metadata location] observable Observable (0..1) buyerSeller BuyerSeller (0..1) settlementTerms SettlementTerms (0..1) effectiveDate AdjustableOrRelativeDate (0..1) Note: The conditions for this data type are excluded from the snippet above for purposes of brevity. The price, quantity and observable attributes are joined together in a single PriceQuantity data type because in some cases, those 3 attributes need to be considered together. For example, the return leg of an Equity Swap will have: the identifier for the shares as observable the number of shares as quantity the initial share price as price However, those attributes are optional because in other cases, only some of them will be specified. In the fixed leg of an Interest Rate Swap, there is no observable as the rate is already fixed. An option trade will contain an instance of a PriceQuantity containing only the premium as price attribute, but no quantity or observable (the quantity and/or observable for the option underlyer will be specified in a different PriceQuantity instance). Both the price and quantity can be specified as arrays in a single PriceQuantity . All elements in the array express the same values but according to different conventions. For example, the return leg of an Equity Swap may specify both the number of shares and the notional (a currency amount equal to: number of shares x price per share) as quantities. In a Forward FX trade, the spot rate, forward points and forward rate (equal to spot rate + forward points) may all be specified as prices. When mutiple values are specified for either the price or quantity attributes in a single PriceQuantity instance, they will be tied by rules that enforce that they are internally consistent. The effective date attribute is optional and will usually be specified when a single trade has multiple trade lots, to indicate when each trade lot become effective (usually on or around the date when the lot was traded). The trade itself will have an effective date, corresponding to the date when the first lot was traded and the trade opened. The price and quantity attributes in the PriceQuantity data type each have a metadata location which can reference a metadata address in one of the Payout data types. The metadata address-location pair allows for a reference to link objects without populating the address object in persistence. This capability helps to support an agnostic definition of the product in a trade (i.e. a product definition without a price and quantity). However, the reference can be used to populate values for an input into a function or for other purposes. Measure ​ A measure is a basic component that is useful in the definition of price and quantity (both things that can be measured) and consists of two attributes: value , which is defined as a number and could be a price or a quantity unit , which defines the unit in which that value is expressed MeasureBase defines the basic structure of a measure in which both attributes are optional. Various other data types that extend MeasureBase can further constrain the existence of those attributes: for instance, a Measure requires the value attribute to be present (but unit is still optional because a measure could be unit-less). type MeasureBase: value number (0..1) unit UnitType (0..1) type Measure extends MeasureBase: condition ValueExists: value exists The UnitType data type used to defined the unit attribute requires the definition of units using one of five defined types: type UnitType: capacityUnit CapacityUnitEnum (0..1) weatherUnit WeatherUnitEnum (0..1) financialUnit FinancialUnitEnum (0..1) currency string (0..1) [metadata scheme] condition UnitType: one-of A measure can vary over time. One often used case is a series of measures indexed by date. Such measures are all homogeneous, so the unit only needs to be represented once. To represent this, the MeasureSchedule type extends MeasureBase with a set of date and value pair attributes represented by the DatedValue type. In that structure, the existing value attribute can still be omitted but, when present, represents the schedule's initial value. type MeasureSchedule extends MeasureBase: datedValue DatedValue (0..*) condition ValueExists: value exists or datedValue exists The price and quantity concepts for financial instruments are both modelled as extensions of the MeasureSchedule data type, as detailed below. This means that by default, price and quantity are considered as schedules although they can also represent a single value when the datedValue attribute is omitted. Price ​ The PriceSchedule data type extends the MeasureSchedule data type with the addition of the priceExpression and perUnitOf attributes, which together further qualify the price. type PriceSchedule extends MeasureSchedule: perUnitOf UnitType (0..1) priceType PriceTypeEnum (1..1) priceExpression PriceExpressionEnum (0..1) composite PriceComposite (0..1) arithmeticOperator ArithmeticOperationEnum (0..1) cashPrice CashPrice (0..1) Note that the conditions for this data type are excluded from the snippet above for purposes of brevity. The Price data type further constrains the PriceSchedule data type by requiring the datedValue attribute to be absent. type Price extends PriceSchedule: condition AmountOnlyExists: value exists and datedValue is absent Consider the example below for the initial price of the underlying equity in a single-name Equity Swap, which is a net price of 37.44 USD per Share: ""price"": [ { ""value"": { ""value"": 37.44, ""unit"": { ""currency"": { ""value"": ""USD"" } }, ""perUnitOf"": { ""financialUnit"": ""SHARE"" }, ""priceExpression"": { ""priceType"": ""ASSET_PRICE"", ""grossOrNet"": ""NET"" }, }, ""meta"": { ""location"": [ { ""scope"": ""DOCUMENT"", ""value"": ""price-1"" } ] } } ] The full form of this example can be seen by ingesting one of the samples provided in the CDM distribution under products / equity / eqs-ex01-single-underlyer-execution-long-form-other-party.xml. As can be seen in the full example, for an interest rate leg, the unit and the perUnitOf would both be a currency (e.g. 0.002 USD per USD). The priceType would be an InterestRate and, in the case of a floating leg, the spreadType would be a Spread. Quantity ​ The QuantitySchedule data type also extends the MeasureSchedule data type with the addition of an optional multiplier attributes. It also requires the unit attribute to exist, i.e. a quantity cannot be unit-less. The NonNegativeQuantitySchedule data type further constrains it by requiring that all the values are non-negative. type QuantitySchedule extends MeasureSchedule: multiplier Measure (0..1) frequency Frequency (0..1) condition Quantity_multiplier: if multiplier exists then multiplier -> value >= 0.0 condition UnitOfAmountExists: unit exists type NonNegativeQuantitySchedule extends QuantitySchedule: condition NonNegativeQuantity_amount: if value exists then value >= 0.0 and if datedValue exists then datedValue -> value all >= 0.0 The inherited attributes of value , unit and datedValue (in case the quantity is provided as a schedule) are sufficient to define a quantity in most cases. The additional multiplier attribute that is provided for the QuantitySchedule data type allows to further qualify the value . This is needed for listed contracts or other purposes, as shown below. In this example, the trade involves the purchase or sale of 200 contracts of the WTI Crude Oil futures contract on the CME. Each contract represents 1,000 barrels, therefore the total quantity of the trade is for 200,000 barrels. ""quantity"": [ { ""value"": { ""value"": 200, ""unit"": { ""financialUnit"": ""CONTRACT"" }, ""multiplier"": { ""value"": 1000, ""unit"": ""BBL"" } }, ""meta"": { ""location"": [ { ""scope"": ""DOCUMENT"", ""value"": ""quantity-1"" } ] } } ] The frequency attribute is used in a similar way when a quantity may be defined based on a given time period, e.g. per hour or per day. In this case, the quantity needs to be multiplied by the size of the relevant period where it applies, e.g. a number of days, to get the total quantity. Observable ​ The Observable data type specifies the reference object to be observed for a price, which could be an underlying asset or a reference such as an index. The Observable data type requires the specification of either a rateOption (i.e. a floating rate index), commodity , productIdentifier , or currencypair . This choice constraint is supported by specifying a one-of condition, as shown below: type Observable: [metadata key] rateOption FloatingRateOption (0..1) [metadata location] commodity Commodity (0..1) [metadata location] productIdentifier ProductIdentifier (0..*) [metadata location] currencyPair QuotedCurrencyPair (0..1) [metadata location] optionReferenceType OptionReferenceTypeEnum (0..1) condition ObservableChoice: required choice rateOption, commodity, productIdentifier, currencyPair SettlementTerms ​ In both the Equity Swap and Interest Rate Swap trade cases mentioned above, there are no settlement terms attached to the price and quantity. Instead, any future settlement is driven by the product mechanics and the price and quantity are just parameters in the definition of that product. In other cases, it is necessary to define settlement terms when either the price or quantity or both are to be settled. A non-exhaustive list of cases includes: A cash transaction, i.e. when buying a certain quantity of a security or commodity for a certain price An FX spot of forward transaction An option for which a premium must be paid A swap transaction that involves an upfront payment, e.g. in case of unwind or novation In those cases, the corresponding PriceQuantity object also contains settlementTerms and buyerSeller attributes to define that settlement. The actual settlement amounts will use the price and quantity agreed as part of the tradable product. The SettlementTerms data type defines the basic characteristics of a settlement: the settlement date, currency, whether it will be cash or physical, and the type of transfer. For instance, a settlement could be a delivery-versus-payment scenario for a cash security transaction or a payment-versus-payment scenario for an FX spot or forward transaction. Those parameters that are common across all settlement methods are captured by the SettlementBase data type. Cash and physical settlement methods require different, specific parameters which are captured by the additional cashSettlementTerms and physicalSettlementTerms attributes, respectively. For instance, a non-deliverable FX forward will use the cashSettlementTerms attribute to represent the parameters of the non-deliverable settlement, such as the observable FX fixing to use. type SettlementTerms extends SettlementBase: cashSettlementTerms CashSettlementTerms (0..*) physicalSettlementTerms PhysicalSettlementTerms (0..1) type SettlementBase: [metadata key] settlementType SettlementTypeEnum (1..1) transferSettlementType TransferSettlementEnum (0..1) settlementCurrency string (0..1) [metadata scheme] settlementDate SettlementDate (0..1) settlementCentre SettlementCentreEnum (0..1) settlementProvision SettlementProvision (0..1) standardSettlementStyle StandardSettlementStyleEnum (0..1) BuyerSeller ​ When a settlement occurs for the price and/or quantity, it is necessary to define the direction of that settlement by specifying which party pays what. That direction is captured by the BuyerSeller data type, that uses the normalised CounterpartyRoleEnum enumeration to specify who is the buyer and seller, respectively. type BuyerSeller: buyer CounterpartyRoleEnum (1..1) seller CounterpartyRoleEnum (1..1) By convention, the direction of the settlement flows will be inferred as follows: the buyer receives the quantity / pays the price, and the seller receives the price / pays the quantity. For instance in an FX spot or forward transaction, the respective units of the quantity and price will determine who is paying or receiving each currency. Financial Product ​ A financial product is an instrument that is used to transfer financial risk between two parties. Financial products are represented in the Product type, which is also constrained by a one-of condition, meaning that for a single Tradable Product, there can only be one Product. type Product: [metadata key] contractualProduct ContractualProduct (0..1) index Index (0..1) loan Loan (0..1) assetPool AssetPool (0..1) foreignExchange ForeignExchange (0..1) commodity Commodity (0..1) [metadata address ""pointsTo""=Observable->commodity] security Security (0..1) basket Basket (0..1) condition: one-of The CDM allows any one of these products to included in a trade or used as an underlier for another product (see the Underlier section). One unlikely case for a direct trade is Index, which is primarily used as an underlier. Among this set of products, the contractual product is the most complicated and requires the largest data structure. In a contractual product, an exchange of financial risk is materialised by a unique bilateral contract that specifies the financial obligations of each party. The terms of the contract are specified at trade inception and apply throughout the life of the contract (which can last for decades for certain long-dated products), unless amended by mutual agreement. Contractual products are fungible (in other words, replaceable by other identical or similar contracts) only under specific terms: e.g. the existence of a close-out netting agreement between the parties. Given that each contractual product transaction is unique, all of the contract terms must be specified and stored in an easily accessible transaction lifecycle model so that each party can evaluate the financial and counterparty risks during the life of the agreement. Foreign Exchange (FX) spot and forward trades (including Non-Deliverable Forwards) and private loans also represent an exchange of financial risk represented by a form of bilateral agreements. FX forwards and private loans can have an extended term, and are generally not fungible. However, these products share few other commonalities with contractual products such as Interest Rate Swaps. Therefore, they are defined separately. By contrast, in the case of the execution of a security (e.g. a listed equity), the exchange of finanical risk is a one-time event that takes place on the settlement date, which is usually within a few business days of the agreement. The other significant distinction is that securities are fungible instruments for which the terms and security identifiers are publically available. Therefore, the terms of the security do not have to be stored in a transaction lifecycle model, but can be referenced with public identifiers. An Index product is an exception because it's not directly tradable, but is included here because it can be referenced as an underlier for a tradable product and can be identified by a public identifier. Contractual Product ​ The scope of contractual products in the current model are summarized below: Interest rate derivatives : Interest Rate Swaps (incl. cross-currency swaps, non-deliverable swaps, basis swaps, swaps with non-regular periods, ...) Swaptions Caps/floors FRAs OTC Options on Bonds Credit derivatives : Credit Default Swaps (incl. baskets, tranche, swaps with mortgage and loans underlyers, ...) Options on Credit Default Swaps Equity derivatives : Equity Swaps (single name) Options : Any other OTC Options (incl. FX Options) Securities Lending : Single underlyer, cash collateralised, open/term security loan Repurchase Agreements : Open Term, Fixed Term, Fixed Rate, Floating Rate In the CDM, contractual products are represented by the ContractualProduct type: type ContractualProduct extends ProductBase: [metadata key] [metadata template] economicTerms EconomicTerms (1..1) Note that price, quantity and counterparties are defined in TradableProduct as these are attributes common to all products. The remaining economic terms of the contractual product are defined in EconomicTerms which is an encapsulated type in ContractualProduct . Economic Terms ​ The CDM specifies the various sets of possible remaining economic terms using the EconomicTerms type. This type includes contractual provisions that are not specific to the type of payout, but do impact the value of the contract, such as effective date, termination date, date adjustments, and early termination provisions. A valid population of this type is constrained by a set of conditions which are not shown here in the interests of brevity. type EconomicTerms: effectiveDate AdjustableOrRelativeDate (0..1) terminationDate AdjustableOrRelativeDate (0..1) dateAdjustments BusinessDayAdjustments (0..1) payout Payout (1..1) terminationProvision TerminationProvision (0..1) calculationAgent CalculationAgent (0..1) nonStandardisedTerms boolean (0..1) collateral Collateral (0..1) Payout ​ The Payout type defines the composable payout types, each of which describes a set of terms and conditions for the financial responsibilities between the contractual parties. Payout types can be combined to compose a product. For example, an Equity Swap can be composed by combining an InterestRatePayout and an PerformancePayout . type Payout: [metadata key] interestRatePayout InterestRatePayout (0..*) creditDefaultPayout CreditDefaultPayout (0..1) optionPayout OptionPayout (0..*) commodityPayout CommodityPayout (0..*) forwardPayout ForwardPayout (0..*) fixedPricePayout FixedPricePayout (0..*) securityPayout SecurityPayout (0..*) [deprecated] cashflow Cashflow (0..*) performancePayout PerformancePayout (0..*) assetPayout AssetPayout (0..*) A number of payout types extend a common data type called PayoutBase . This data type provides a common structure for attributes such as quantity, price, settlement terms and the payer/receiver direction which are expected to be common across many payouts. type PayoutBase: payerReceiver PayerReceiver (1..1) priceQuantity ResolvablePriceQuantity (0..1) principalPayment PrincipalPayments (0..1) settlementTerms SettlementTerms (0..1) The list of payouts that extend PayoutBase are: InterestRatePayout CreditDefaultPayout OptionPayout CommodityPayout ForwardPayout FixedPricePayout SecurityPayout Cashflow PerformancePayout AssetPayout the ProtectionTerms data type encapsulated in CreditDefaultPayout For example: type InterestRatePayout extends PayoutBase: [metadata key] rateSpecification RateSpecification (0..1) dayCountFraction DayCountFractionEnum (0..1) [metadata scheme] calculationPeriodDates CalculationPeriodDates (0..1) paymentDates PaymentDates (0..1) paymentDate AdjustableDate (0..1) paymentDelay boolean (0..1) resetDates ResetDates (0..1) discountingMethod DiscountingMethod (0..1) compoundingMethod CompoundingMethodEnum (0..1) cashflowRepresentation CashflowRepresentation (0..1) stubPeriod StubPeriod (0..1) bondReference BondReference (0..1) fixedAmount calculation (0..1) floatingAmount calculation (0..1) Note: The code snippets above excludes the conditions in this data type for purposes of brevity. The price and quantity attributes in the PayoutBase structure are positioned in the ResolvablePriceQuantity data type. This data type mirrors the PriceQuantity data type and contains both the price and quantity schedules. In addition that data type supports the definition of additional information such as a quantity reference, a quantity multiplier or the indication that the quantity is resettable. Those are used to describe the quantity of a payout leg that may need to be calculated based on other inputs: e.g. an exchange rate for the foreign leg in a Cross-Currency Swap or a share price for the funding leg of an Equity Swap. type ResolvablePriceQuantity: [metadata key] quantityCumulation CumulationFeature (0..*) resolvedQuantity Quantity (0..1) quantitySchedule NonNegativeQuantitySchedule (0..1) [metadata address ""pointsTo""=PriceQuantity->quantity] quantityReference ResolvablePriceQuantity (0..1) [metadata reference] quantityMultiplier QuantityMultiplier (0..1) reset boolean (0..1) futureValueNotional FutureValueAmount (0..1) priceSchedule PriceSchedule (0..*) [metadata address ""pointsTo""=PriceQuantity->price] By design, the CDM requires that each payout leg can only be associated with a single quantity schedule that defines this leg's contractual behaviour (e.g. for the payment of cashflows). In the PriceQuantity object, where that attribute is of multiple cardinality, other quantities may be provided ""for information only"" which can be inferred from the main quantity used in the payout leg: e.g. when a commodity quantity is associated to a frequency and needs to be multiplied by the period to get the total quantity. Both the quantitySchedule and priceSchedule attributes have a metadata address that point respectively to the quantity and price attributes in the PriceQuantity data type. This special cross-referencing annotation in the Rosetta DSL allows to parameterise an attribute whose value may be variable by associating it to an address. The attribute value does not need to be populated in the persisted object and can be provided by another object, using the address as a reference. Other model structures use the [metadata address] to point to PriceQuantity->price . An example include the price attribute in the RateSchedule data type, which is illustrated below: type RateSchedule: price PriceSchedule (1..1) [metadata address ""pointsTo""=PriceQuantity->price] Reusable Components ​ There are a number of components that are reusable across several payout types. For example, the CalculationPeriodDates class describes the inputs for the underlying schedule of a stream of payments. type CalculationPeriodDates: [metadata key] effectiveDate AdjustableOrRelativeDate (0..1) terminationDate AdjustableOrRelativeDate (0..1) calculationPeriodDatesAdjustments BusinessDayAdjustments (0..1) firstPeriodStartDate AdjustableOrRelativeDate (0..1) firstRegularPeriodStartDate date (0..1) firstCompoundingPeriodEndDate date (0..1) lastRegularPeriodEndDate date (0..1) stubPeriodType StubPeriodTypeEnum (0..1) calculationPeriodFrequency CalculationPeriodFrequency (0..1) Underlier ​ The underlier attribute on types OptionPayout , ForwardPayout and EquityPayout allows for any product to be used as the underlier for a corresponding products option, forward, and equity swap. type OptionPayout extends PayoutBase: [metadata key] buyerSeller BuyerSeller (1..1) optionType OptionTypeEnum (0..1) feature OptionFeature (0..1) exerciseTerms OptionExercise (1..1) underlier Product (1..1) This nesting of the product component is another example of a composable product model. One use case is an interest rate swaption for which the high-level product uses the OptionPayout type and underlier is an Interest Rate Swap composed of two InterestRatePayout types. Similiarly, the product underlying an Equity Swap composed of an InterestRatePayout and an EquityPayout would be a non-contractual product: an equity security. Data Templates ​ The ContractualProduct type is specified with the [metadata template] annotation indicating that it is eligible to be used as a template. Financial markets often trade a high volume of trades with near identical contractual product data. Templates provide a way to store this data more efficiently. The contractual product data which is duplicated on each contract can be extracted into a single template and replaced by a reference. This allows each trade to specify only the unique contractual product data. The template reference can be resolved to a template object which can then be merged in to form a single, complete object. For instance, Equity Swaps used by Equity Financing desks sometimes refer to a Master Confirmation agreement, which is an overall agreement that specifies all the standard Equity Swap terms that do not need to be renegotiated on each trade. Each contractual product would only specify the unique product details (such as start and end date, underlier, price and spread) together with a reference to the Master Confirmation containing the template product details. Code libraries, written in Java and distributed with the CDM, contain tools to merge CDM objects together. Implementors may extend these merging tools to change the merging strategy to suit their requirements. The CDM Java Examples download, available via the CDM Portal Downloads page , contains a example demonstrating usage of a data template and the merging tools. See com.regnosys.cdm.example.template.TemplateExample . Products with Identifiers ​ The abstract data type ProductBase serves as a base for all products that have an identifier, as illustrated below: type ProductBase: productTaxonomy ProductTaxonomy (0..*) productIdentifier ProductIdentifier (0..*) The data types that extend from ProductBase are Index, Commodity, Loan, and Security. Index and Commodity do not have any additional attributes. In the case of Commodity, the applicable product identifiers are the ISDA definitions for reference benchmarks. Loan and Security both have a set of additional attributes, as shown below: type Loan extends ProductBase: borrower LegalEntity (0..*) lien string (0..1) [metadata scheme] facilityType string (0..1) [metadata scheme] creditAgreementDate date (0..1) tranche string (0..1) [metadata scheme] type Security extends ProductBase: securityType SecurityTypeEnum (1..1) debtType DebtType (0..1) equityType EquityTypeEnum (0..1) fundType FundProductTypeEnum (0..1) economicTerms EconomicTerms (0..1) condition DebtSubType: if securityType <> SecurityTypeEnum -> Debt then debtType is absent condition EquitySubType: if securityType <> SecurityTypeEnum -> Equity then equityType is absent condition FundSubType: if securityType <> SecurityTypeEnum -> Fund then fundType is absent The product identifier will uniquely identify the security. The securityType is required for specific purposes in the model, for example for validation as a valid reference obligation for a Credit Default Swap. The additional security details are optional as these could be determined from a reference database using the product identifier as a key Product Qualification Product qualification is inferred from the economic terms of the product instead of explicitly naming the product type. The CDM uses a set of Product Qualification functions to achieve this purpose. These functions are identified with a [qualification Product] annotation. A Product Qualification function applies a taxonomy-specific business logic to identify if the product attribute values, as represented by the product's economic terms, match the specified criteria for the product named in that taxonomy. For example, if a certain set of attributes are populated and others are absent, then that specific product type is inferred. The Product Qualification function name in the CDM begins with the word Qualify followed by an underscore _ and then the product type from the applicable taxonomy (also separated by underscores). The CDM implements the ISDA Product Taxonomy v2.0 to qualify contractual products, foreign exchange, and repurchase agreements. Given the prevalence of usage of the ISDA Product Taxonomy v1.0, the equivalent name from that taxonomy is also systematically indicated in the CDM, using a synonym annotation displayed under the function output. An example is provided below for the qualification of a Zero-Coupon Fixed-Float Inflation Swap: func Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon: [qualification Product] inputs: economicTerms EconomicTerms (1..1) output: is_product boolean (1..1) [synonym ISDA_Taxonomy_v2 value ""InterestRate_IRSwap_Inflation""] set is_product: Qualify_BaseProduct_Inflation(economicTerms) = True and Qualify_BaseProduct_CrossCurrency( economicTerms ) = False and Qualify_SubProduct_FixedFloat(economicTerms) = True and Qualify_Transaction_ZeroCoupon(economicTerms) = True If all the statements above are true, then the function evaluates to True, and the product is determined to be qualified as the product type referenced by the function name. Note: In a typical CDM model implementation, the full set of Product Qualification functions would be invoked against each instance of the product in order to determine the inferred product type. Given the product model composability, a single product instance may be qualified as more than one type: for example in an Interest Rate Swaption, both the Option and the underlying Interest Rate Swap would be qualified. The CDM supports Product Qualification functions for Credit Derivatives, Interest Rate Derivatives, Equity Derivatives, Foreign Exchange, and Repurchase Agreements. The full scope for Interest Rate Products has been represented down to the full level of detail in the taxonomy. This is shown in the example above, where the ZeroCoupon qualifying suffix is part of the function name. Credit Default products are qualified, but not down to the full level of detail. The ISDA Product Taxonomy v2.0 references the FpML transaction type field instead of just the product features, whose possible values are not publicly available and hence not positioned as a CDM enumeration. The output of the qualification function is used to populate the productQualifier attribute of the ProductTaxonomy object, which is created when a ContractualProduct object is created. The product taxonomy includes both the product qualification generated by the CDM and any additional product taxonomy information which may come from the originating document, such as FpML. In this case, taxonomy schemes may be associated to such product taxonomy information, which are also propagated in the ProductTaxonomy object. Many different financial taxonomies may be used by various segments of the financial industry to describe the same product. To support a multitude of taxonomies without adding any specific identity to data types in the model, a Taxonomy type is used to identify the source and attributes any particular taxonomy structure. type Taxonomy: source TaxonomySourceEnum (0..1) value TaxonomyValue (0..1) TaxonomyValue has been expanded to represent a complex type: type TaxonomyValue: name string (0..1) [metadata scheme] classification TaxonomyClassification (0..*) condition ValueExists: name exists or classification exists TaxonomyClassification is also a complex type that support a hierarchical structure of any depth: type TaxonomyClassification: className string (0..1) value string (1..1) description string (0..1) ordinal int (0..1) The ProductTaxonomy data structure and an instance of a CDM object ( serialised into JSON) are shown below: type ProductTaxonomy extends Taxonomy: primaryAssetClass AssetClassEnum (0..1) [metadata scheme] secondaryAssetClass AssetClassEnum (0..*) [metadata scheme] productQualifier string (0..1) condition TaxonomyType: required choice source, primaryAssetClass, secondaryAssetClass condition TaxonomySource: if source exists then ( value exists or productQualifier exists ) condition TaxonomyValue: optional choice value, productQualifier ""productTaxonomy"": [ { ""primaryAssetClass"": { ""meta"": { ""scheme"": ""http://www.fpml.org/coding-scheme/asset-class-simple"" }, ""value"": ""INTEREST_RATE"" }, }, { ""taxonomyValue"": { ""meta"": { ""scheme"": ""http://www.fpml.org/coding-scheme/product-taxonomy"" }, ""value"": ""InterestRate:IRSwap:FixedFloat"" } ""taxonomySource"": ""ISDA"" }, { ""productQualifier"": ""InterestRate_IRSwap_FixedFloat"", ""taxonomySource"": ""ISDA"" } ]"
Pre-trade_Processing.txt,"Main Menu Pre-trade Processing Version: 5.13.0 On this page Pre-trade Processing Introduction ​ Pre-trade processing is an important part of the trade lifecycle. It can involve a large number of steps, including initiation tasks like order routing, risk management assessment and compliance checking, as well as the actual trade negotiation, affirmation and confirmation. Pre-trade in Securities Lending ​ In securities lending a lender will broadcast their availability to lend specific securities to potential borrowers. This process allows borrowers to easily identify and select lenders who have the desired securities available for lending and can help facilitate trades more quickly and efficiently. A borrower can also approach a lender directly in order to ascertain whether they have a security available to borrow. This request could be sent to one or more lenders, depending on the borrower's requirements. Lenders regularly only share the bare minimum amount of detail when presenting their availability, often including only the security identifier. When responding to a request for a security from a borrower then the lender may provide a lot more detail, including interest rates and acceptable types of collateral. Modelling the broadcast of available securities ​ A lender will distribute anywhere from one to several thousand availability records to the market or individual borrowers. The model represents this using two types: AvailableInventory and AvailableInventoryRecord . AvailableInventory is designed to hold a list of AvailableInventoryRecord items, with each item within AvailableInventoryRecord representing a specific piece of availability i.e. a security being held by a lender or custodian. Thus, for a lender to model a broadcast of say 10 different pieces of availability, the structure required would consist of one AvailableInventory with a list of 10 AvailableInventoryRecord items within it. AvailableInventory ​ As described above, AvailableInventory is used to hold the entire set of availability that the lender wants to distribute. This is where details that pertain to the overall availability and the records held within it should be specified. type AvailableInventory: availableInventoryType AvailableInventoryTypeEnum (1..1) messageInformation MessageInformation (0..1) party Party (0..*) partyRole PartyRole (0..*) availableInventoryRecord AvailableInventoryRecord (0..*) The attributes available are: The availableInventoryType is a mandatory enumeration which is used to describe the purpose of this AvailableInventory instance. For the lender availability use case this should be set to "" AvailableToLend "" The optional messageInformation type allows details related to a message containing the availability to be described if required. The party attribute here describes all parties involved in this set of availability. For example, this could include the sender of the availability, the intended recipient, the beneficial owner(s), the lender (which may differ from the sender as the lender may have the same piece of availability going through multiple agents), an agent or a venue. Each of the parties included in the party type can be assigned a partyRole . The ValidPartyRole condition within AvailableInventory restricts the types of role that can be assigned in this context. Valid roles are: "" AgentLender "", "" BeneficialOwner "", "" Borrower "", "" Custodian "" or "" Lender "" The availableInventoryRecord record is where the securities that are to be shown as available should be listed. AvailableInventoryRecord ​ The AvailableInventoryRecord type is an array that is used to hold the list of availability records that the lender wants to broadcast. Each availability record will need to include details of the security and any associated criteria e.g. the quantity of shares available, the rate at which the security is available to borrow at. This type inherits additional mandatory types from the generic InventoryRecord type which it extends. type InventoryRecord: identifer AssignedIdentifier (1..1) security Security (1..1) The identifier and security should be used as follows: The identifier type is mandatory and is used to assign a specific reference to this availability record. This allows the parties to uniquely identify any row of availability. The security type allows the key security information to be provided, including the securityType and identifier for the instrument. The AvailableInventoryRecord itself allows the most common datapoints shared when distributing availability to be specified. type AvailableInventoryRecord extends InventoryRecord: expirationDateTime zonedDateTime (0..1) collateral CollateralProvisions (0..*) partyRole PartyRole (0..*) quantity Quantity (0..1) interestRate Price (0..1) These attributes are all optional and should be used as follows: Where a time limit/restriction needs to be set against a piece of availability then the expirationDateTime attribute can be used to express it. The collateral type allows the lender to specify the type of collateral required for a specific piece of availability. In this context the partyRole is primarily used to reference parties that have already been defined in the party attribute of the top level AvailableInventory type. It can also be used here to define the role of a party at the individual security level if necessary (which could be required if a security is held by multiple agents). There is a ValidPartyRole condition within AvailableInventoryRecord that restricts the types of role that can be assigned in this context to: "" AgentLender "", "" BeneficialOwner "", "" Custodian "" or "" Lender "". The quantity attribute can be used to specify the number of shares that are available. Note that this attribute is optional, the lender may want to only broadcast the fact that they have a security available to drum up interest. The interestRate attribute allows the lender to specify a rate that is required for a piece of availability. The InterestRate condition within AvailableInventoryRecord ensures that the interestRate -> priceType is set to "" InterestRate "" if interestRate is included here. Examples ​ In this section some examples of valid JSON describing availability are provided. Several different examples are provided to assist the user when attempting to model their own availability. Single security ​ In this very simple example a party is broadcasting their availability for a single ISIN. Very limited details are provided implying that this is general availability targeted at the entire market. { ""availableInventoryType"": ""AvailableToLend"", ""availableInventoryRecord"": [ { ""identifier"": { ""identifier"": ""00001"" }, ""security"": { ""securityType"": ""Equity"", ""productIdentifier"": { ""identifier"": ""GB00000000012"", ""source"": ""ISIN"" } }, ""quantity"": { ""value"": 10000 } } ] } Multiple securities ​ Building upon the last example, in this example a party is broadcasting their availability for two ISINs. This time the party has not included the number of shares that they have available for the first ISIN, ""GB00000000012"", forcing borrowers to request more details before a deal can be negotiated. For the second ISIN, ""GB00000000013"", they have included some specific lending criteria to help the borrowers decide if they want to proceed with a loan. { ""availableInventoryType"": ""AvailableToLend"", ""availableInventoryRecord"": [ { ""identifier"": { ""identifier"": ""00001"" }, ""security"": { ""securityType"": ""Equity"", ""productIdentifier"": { ""identifier"": ""GB00000000012"", ""source"": ""ISIN"" } } }, { ""identifier"": { ""identifier"": ""00002"" }, ""security"": { ""securityType"": ""Equity"", ""productIdentifier"": { ""identifier"": ""GB00000000013"", ""source"": ""ISIN"" } }, ""quantity"": { ""value"": 1800000 }, ""interestRate"": { ""priceType"": ""InterestRate"", ""value"": 0.025, ""unit"": { ""currency"": ""GBP"" } } } ] } Securities held by an agent lender ​ In this final example, an agent lender is broadcasting the availability that they have for a single security. They specify that they require other securities as collateral in a loan using this piece of availability (as they have set the collateral -> collateralType enumeration to "" NonCash ""). The details of the agent lender are also included so recipients of the availability will know that they are acting as an agent in this instance. { ""availableInventoryType"": ""AvailableToLend"", ""party"": [ { ""partyId"": { ""identifier"": { ""value"": ""AGENT1"" } }, ""name"": { ""value"": ""Agency Services Limited"" }, ""meta"": { ""globalKey"": ""x123rt"", ""externalKey"": ""agent1"" } } ], ""partyRole"": [ { ""partyReference"": { ""globalReference"": ""x123rt"", ""externalReference"": ""agent1"" }, ""role"": ""AgentLender"" } ], ""availableInventoryRecord"": [ { ""identifier"": { ""identifier"": ""00001"" }, ""security"": { ""securityType"": ""Equity"", ""productIdentifier"": { ""identifier"": ""GB00000000013"", ""source"": ""ISIN"" } }, ""quantity"": { ""value"": 20000 }, ""collateral"": [ { ""collateralType"": ""NonCash"" } ] } ] } Modelling the borrower request ​ When a borrower needs a security to cover a short position, or for some other trading strategy, they can approach specific lenders or the general market to locate the shares that they need. The model represents this using two types: SecurityLocate and AvailableInventoryRecord . SecurityLocate is designed to hold a list of AvailableInventoryRecord items, with each item within AvailableInventoryRecord representing a specific security that the borrower is looking to locate. Thus, for a borrower to locate 10 different securities, the structure required would consist of one SecurityLocate with a list of 10 AvailableInventoryRecord items within it. SecurityLocate ​ As described above, SecurityLocate is used to hold the entire set of securities that the borrower wants to locate. This is where details that pertain to the overall request should be specified. type SecurityLocate extends AvailableInventory: Note: SecurityLocate is an extension of AvailableInventory and thus inherits all the data points from within it. type AvailableInventory: availableInventoryType AvailableInventoryTypeEnum (1..1) messageInformation MessageInformation (0..1) party Party (0..*) partyRole PartyRole (0..*) availableInventoryRecord AvailableInventoryRecord (0..*) The attributes available in SecurityLocate are thus: The availableInventoryType is a mandatory enumeration which is used to describe the purpose of this SecurityLocate instance. For the borrower request use case this should be set to "" RequestToBorrow "" The optional messageInformation type allows details related to a message containing the request to be described if required. The party attribute here describes all parties involved in this request. For example, this could include the sender of the request, the intended recipient, the beneficial owner(s), the lender, an agent or a venue. Each of the parties included in the party type can be assigned a partyRole . The ValidPartyRole condition within SecurityLocate restricts the types of role that can be assigned in this context. Valid roles are: "" AgentLender "", "" BeneficialOwner "", "" Borrower "", "" Custodian "" or "" Lender "" The availableInventoryRecord record is where the securities that are being requested should be listed. The RequestOneSecurityMinimum condition enforces the presence of at least one availableInventoryRecord here, as a request must include at least one security. AvailableInventoryRecord ​ The AvailableInventoryRecord type is an array that is used to hold the list of securities that the borrower wants to locate. Each record will need to include details of the security and optionally include any associated criteria e.g. the quantity of shares the borrower requires. This type inherits additional mandatory types from the generic InventoryRecord type which it extends. type InventoryRecord: identifer AssignedIdentifier (1..1) security Security (1..1) The identifier and security should be used as follows: The identifier type is mandatory and is used to assign a specific reference to this request. This allows the parties to uniquely identify any request. The security type allows the key security information to be provided, including the securityType and identifier for the instrument. The AvailableInventoryRecord itself allows the most common datapoints shared when requesting securities to be specified. Note that in the context of a borrower request, a lot of these datapoints will not be required. type AvailableInventoryRecord extends InventoryRecord: expirationDateTime zonedDateTime (0..1) collateral CollateralProvisions (0..*) partyRole PartyRole (0..*) quantity Quantity (0..1) interestRate Price (0..1) These attributes are all optional and should be used as follows: Where a time limit/restriction needs to be set against a request for a security then the expirationDateTime attribute can be used to express it. The collateral type allows the borrower to specify the type of collateral that they are looking to use for a loan against this security. In this context the partyRole is primarily used to reference parties that have already been defined in the party attribute of the top level SecurityLocate type. It can also be used here to define the role of a party at the individual security level if necessary. There is a ValidPartyRole condition within AvailableInventoryRecord that restricts the types of role that can be assigned in this context to: "" AgentLender "", "" BeneficialOwner "", "" Custodian "" or "" Lender "". The quantity attribute can be used to specify the number of shares that the borrower requires. The interestRate attribute allows the borrower to specify the rate that they are looking to pay for a loan against this security. The InterestRate condition within AvailableInventoryRecord ensures that the interestRate -> priceType is set to "" InterestRate "" if interestRate is included here. Examples ​ In this section some examples of valid JSON describing borrower requests are provided. Several different examples are provided to assist the user when attempting to model their own requests. Single security ​ In this very simple example a borrower is requesting if any lenders have a single ISIN available for them to borrow. No parties are specified implying that this is a general request targeted at the entire market. Note that no quantity is specified either, the borrower is first seeing who has any availability for this security. { ""availableInventoryType"": ""RequestToBorrow"", ""availableInventoryRecord"": [ { ""identifier"": { ""identifier"": ""00001"" }, ""security"": { ""securityType"": ""Equity"", ""productIdentifier"": { ""identifier"": ""GB00000000012"", ""source"": ""ISIN"" } } } ] } Single security from a particular lender ​ In this example, rather than the borrower sending a request to the entire market, they have specified the agent lender that they want to borrow this ISIN from. They have also included their own party details, setting themselves as the borrower. This time the party has also included the number of shares that they would like to borrow. { ""availableInventoryType"": ""RequestToBorrow"", ""party"": [ { ""partyId"": { ""identifier"": { ""value"": ""BORROWER1"" } }, ""name"": { ""value"": ""ACME Bank"" }, ""meta"": { ""globalKey"": ""pe4h12"", ""externalKey"": ""borrower1"" } }, { ""partyId"": { ""identifier"": { ""value"": ""AGENT1"" } }, ""name"": { ""value"": ""Agency Services Limited"" }, ""meta"": { ""globalKey"": ""x123rt"", ""externalKey"": ""agent1"" } } ], ""partyRole"": [ { ""partyReference"": { ""globalReference"": ""pe4h12"", ""externalReference"": ""borrower1"" }, ""role"": ""Borrower"" }, { ""partyReference"": { ""globalReference"": ""x123rt"", ""externalReference"": ""agent1"" }, ""role"": ""AgentLender"" } ], ""availableInventoryRecord"": [ { ""identifier"": { ""identifier"": ""00001"" }, ""security"": { ""securityType"": ""Equity"", ""productIdentifier"": { ""identifier"": ""GB00000000012"", ""source"": ""ISIN"" } }, ""quantity"": { ""value"": 1800000 }, } ] } Multiple securities from multiple lenders ​ In this final example the borrower is now sending a request for two securities to two agent lenders. Once again they have included their party details too. This time the party has included the number of shares that they would like to borrow for one of the securities, but not for the other. { ""availableInventoryType"": ""RequestToBorrow"", ""party"": [ { ""partyId"": { ""identifier"": { ""value"": ""BORROWER1"" } }, ""name"": { ""value"": ""ACME Bank"" }, ""meta"": { ""globalKey"": ""pe4h12"", ""externalKey"": ""borrower1"" } }, { ""partyId"": { ""identifier"": { ""value"": ""AGENT1"" } }, ""name"": { ""value"": ""Agency Services Limited"" }, ""meta"": { ""globalKey"": ""x123rt"", ""externalKey"": ""agent1"" } }, { ""partyId"": { ""identifier"": { ""value"": ""AGENT2"" } }, ""name"": { ""value"": ""GTR Custody"" }, ""meta"": { ""globalKey"": ""9wq8rg"", ""externalKey"": ""agent2"" } } ], ""partyRole"": [ { ""partyReference"": { ""globalReference"": ""pe4h12"", ""externalReference"": ""borrower1"" }, ""role"": ""Borrower"" }, { ""partyReference"": { ""globalReference"": ""x123rt"", ""externalReference"": ""agent1"" }, ""role"": ""AgentLender"" }, { ""partyReference"": { ""globalReference"": ""9wq8rg"", ""externalReference"": ""agent2"" }, ""role"": ""AgentLender"" } ], ""availableInventoryRecord"": [ { ""identifier"": { ""identifier"": ""00001"" }, ""security"": { ""securityType"": ""Equity"", ""productIdentifier"": { ""identifier"": ""GB00000000012"", ""source"": ""ISIN"" } }, ""quantity"": { ""value"": 1800000 }, }, { ""identifier"": { ""identifier"": ""00002"" }, ""security"": { ""securityType"": ""Equity"", ""productIdentifier"": { ""identifier"": ""GB00000000010"", ""source"": ""ISIN"" } } } ] } Trade Negotiation ​ The following description of a trade negotiation is based upon a more in depth analysis on negotiating a securities lending trade undertaken by ISLA. A full discussion of the process can be found on the ISLA website The CDM is built upon the concept of workflows. Each workflow can be broken down into a series of steps. Each step holds the data required to transition a trade from one state to another. One party can propose a new step in a workflow, and another party (or parties) can accept or reject the proposal. If the proposal is accepted, then the outcome is a new business event. If the proposal is rejected, then no event is generated, and the workflow stops at this point. This process of proposing, rejecting or accepting steps in a workflow can be used to model a trade negotiation through to execution. Securities Lending example ​ In its simplest form, a borrower will propose a new trade execution to a lender, sending them the details of the trade as they see it. The lender will accept the proposed trade and a trade execution business event will be generated. This is a standard Propose-Accept workflow. Note: Additional workflows, including where a lender rejects a proposal or offers a counter proposal, are described in more detail in the previously referenced document available from the ISLA website . Modelling ​ To model this basic Propose-Accept workflow we need to use the elements inside the WorkflowStep type: type WorkflowStep: [metadata key] [rootType] businessEvent BusinessEvent (0..1) counterpartyPositionBusinessEvent CounterpartyPositionBusinessEvent (0..1) proposedEvent EventInstruction (0..1) rejected boolean (0..1) approval WorkflowStepApproval (0..*) previousWorkflowStep WorkflowStep (0..1) [metadata reference] nextEvent EventInstruction (0..1) messageInformation MessageInformation (0..1) timestamp EventTimestamp (1..*) eventIdentifier Identifier (1..*) action ActionEnum (0..1) party Party (0..*) account Account (0..*) lineage Lineage (0..1) [deprecated] creditLimitInformation CreditLimitInformation (0..1) workflowState WorkflowState (0..1) The main items that will be used for this example workflow are: businessEvent is used when an event has been successfully approved proposedEvent holds the details of the event that is being proposed approval allows each party involved in a workflow to set whether they approve the event that is being proposed previousWorkflowStep holds the lineage of all steps in the workflow eventIdentifier holds a unique identifier for this event party can be used to hold parties involved in the workflow Other elements can be used but for this example we will just be describing the usage of these items. Propose ​ In this trade negotiation example, the core data is a new proposed event, which is a trade execution being proposed by the borrower. The details of the execution are held in proposedEvent which is an instance of EventInstruction . This should describe the parties on the trade, the instrument being loaned and the economic terms of the trade. As this is a new proposed event, there is no business event as yet, so the businessEvent will not be included in this workflow step. Similarly, this is the first step in the workflow for this event, so there will be no previous workflow steps either, so previousWorkflowStep will also not be included at this point. An identifier for the trade will be required which should be placed within the eventIdentifier . In order for the proposed execution to become an actual business event both parties to the trade must approve the details of the trade held in proposedEvent . This is controlled using approval , where all parties to the event are defined along with whether they have approved the event or not. When the borrower proposes the new trade execution they will set their approval status to True and the approval status of the lender party to False . This WorkflowStep can now be passed to the lender who will decide whether the terms of the proposed trade held in proposedEvent are acceptable. Accept ​ Once the lender receives a WorkflowStep containing a proposedEvent for a new trade they can then decide whether they accept the terms of the execution or not. If the lender decides that the terms are acceptable then they will need to send a WorkflowStep back to the borrower confirming this. This time the details of the trade will be in businessEvent as opposed to being in proposedEvent , as the lender is essentially agreeing the terms of the execution as held in the proposedEvent from the workflow step that they received from the borrower. The approval status of the lender party in the new workflow step should be updated to True . The approval status of the borrower party should already be set to True from the previous workflow step; thus approval in the new workflow step should now have both the borrower and lender approval statuses both set to True . The new WorkflowStep must also now include a previousWorkflowStep . The WorkflowStep object that the lender received holding the proposed trade execution from the borrower must be copied into the previousWorkFlowStep . This preserves the lineage of the negotiation and will allow both the lender and borrower applications to inspect the entire negotiation process should they need to. Note The details from the original proposedEvent must not be updated when they are put into the previousWorkflowStep . This is because the JSON that the CDM generates can contain metadata references, which need to be preserved so that the references still work correctly. Functions ​ There are several functions available in the CDM to help generate the workflow steps required to perform the negotiation of events like a trade execution. A brief description of some of the functions are provided here. More details and additional functions can be reviewed in the model itself. Creating a proposal ​ To start the negotiation process a party will need to create a new WorkflowStep with the details of the trade execution held in the proposedEvent within it. This can be done using the Create_ProposedWorkflowStep function. Accepting a proposal ​ If a party is happy with a proposal that they have received then they will need to notify the other party that they have accepted the proposal. This can be done by generating a new workflow step that holds a businessEvent rather than a proposedEvent . This can be done by using the Create_AcceptedWorkflowStepFromInstruction function. Rejecting a proposal ​ If a proposal is not acceptable, and the party does not want to continue the negotiation, then the party can send a rejection to the other party. This is achieved by sending a new WorkflowStep back with the rejected attribute set to True . This can be done by using the Create_RejectedWorkflowStep function."
Homepage.txt,Main Menu Homepage Version: 5.13.0 Homepage Welcome to CDM documentation ! Overview of Finos CDM The Common Domain Model product-model event-model legal-agreements process-model reference-data-model mapping namespace Use Cases Eligible Collateral Representation Repurchase Agreement Representation Securities Lending Pre-trade Processing CDM Java Distribution Guidelines Development Guidelines CDM Materials CDM Demos Get Involved Join the Contribution Review Working Group Join the Collateral Working Group Join the Steering Working Group Join the Structured Products Working Group Join the Technology Architecture Working Group Join the Derivatives Product and Business Event Working Group Download
CDM_Contribution_Review_Working_Group.txt,"Main Menu CDM Contribution Review Working Group Version: 5.13.0 On this page CDM Contribution Review Working Group Overview ​ The CDM Contribution Review Working Group (CRWG) plays a crucial role in the CDM ecosystem. We review, approve, and implement contribution proposals to the CDM, ensuring the integrity and quality of the project. Additionally, we serve as arbitrators for any disputes arising from contributions, and we uphold the design principles and guidelines that govern the CDM. Responsibilities ​ Reviews, approves, and implements contribution proposals to the CDM. Arbitrates disputes arising from DWG contributions. Guards and enforces design principles and guidelines. Triage and facilitates long-dated PRs and Issues. Meets fortnightly, with sub-groups as required. Meetings ​ Join us on the First and Third Tuesday at 10 AM EST (3 PM GMT). Email to be added to the meeting invites directly, or find the meeting in the . 2024 Roadmap ​ ​ To subscribe to the CRWG mailing list and stay updated on meetings and agenda, please send an email to cdm-contribution-review+subscribe@lists.finos.org . After sending the email, you will receive a confirmation message. Reply to confirm your subscription. To view meeting notes and agendas, view our current and past GitHub Meeting Issues."
CDM_Steering_Working_Group.txt,"Main Menu CDM Steering Working Group Version: 5.13.0 On this page CDM Steering Working Group Overview ​ This working group serves as the driving force behind the strategic direction and technical aspects of the CDM. We are responsible for establishing technical and modeling guidelines, setting and revising the project’s strategic roadmap, and vetting proposed changes. Additionally, we approve or establish additional working groups to address specific needs within the CDM ecosystem. Responsibilities: ​ Define and monitor the overall roadmap, setting annual priorities. Decide on support for resourcing initiatives proposed by other working groups (TAWG, CRWG, or DWGs). Approve new FINOS Working Groups (WGs). Determine matters of Governance & Operating Model for FINOS CDM WGs. Provide final release approval. Meetings ​ Join us Monthly on the Second Tuesday 11AM EST (4 PM GMT). Email to be added to the meeting invites directly, or find the meeting in the . 2024 Roadmap ​ ​ To subscribe to the Steering Working Group mailing list and stay updated on meetings and agenda, please send an email to cdm-steering-wg+subscribe@lists.finos.org . After sending the email, you will receive a confirmation message. Reply to confirm your subscription. To view meeting notes and agendas, view our current and past GitHub Meeting Issues."
Common_Domain_Model_Materials.txt,"Main Menu Common Domain Model Materials Version: 5.13.0 On this page Common Domain Model Materials Explore More Resources and Videos on the Common Domain Model in the FINOS Resource Center COMMON DOMAIN MODEL IN THE NEWS ​ CDM: Release Guidelines Task Force ​ Watch this video to learn more about the CDM Release Guidelines Task Force. CDM: data standardisation across the trade lifecycle ​ SFT examines what comes next on the Common Domain Model project agenda. Read more about the benefits of CDM adoption include reduced reconciliation burdens and lower risk of settlement failures. The CDM available in FINOS as open source, broadening the base of CDM contributors. Future work includes applying CDM to collateral management and further automating processes like collateral calculation and interest processing. Six major banks trial Fragmos Chain in OTC derivatives market ​ Fragmos Chain successfully trialed its innovative post-trade processing platform for OTC derivatives with six major banks, achieving trade confirmations within an average of 6 minutes. The platform's use of R3 Corda's Distributed Ledger Technology and the Common Domain Model ensured seamless interoperability and efficiency, receiving high praise for handling complex trades. Fintech Open-Source Foundation (FINOS) Chosen to Support Community Around Common Domain Model from ISLA, ISDA, ICMA ​ In this article, Crowdfund Insider discussed the appointment of FINOS as the host of CDM. Viewed as a milestone in promoting open and common standards in financial markets and praised FINOS for its potential to accelerate the adoption of CDM and bring greater consistency across the industry. FINOS Launches Common Domain Model ​ In February 2023, FINOS announced the launch of the Common Domain Model, which aims to to become the industry standard for digital regulatory reporting. The CDM streamlines and automates various lifecycle events and processes related to open repos, evergreens, and floating rate repos - ultimately reducing costs and improving sustainability in regulatory compliance by mutualizing regulatory reporting. The journey towards implementing the CDM is a significant step towards real-world industry implementation of digital regulatory reporting and compliance. See the press coverage here securitiesfinancetimes and FINADIUM. CDM RESOURCES ​ A discussion of ""The Future of the Securities Lending Market: An Agenda for Change"" ​ ISLA published a paper entitled ‘The Future of the Securities Lending Market | An Agenda for Change’ in September 2019, looking at the conjunction of market complexity, technical architecture and regulatory impacts. The conclusion reached was that a transformation was overdue and the solution would be underpinned by common standards. CDM Now Available In Python ​ A recent contribution to the CDM project makes it available in the Python programming language for the first time, which will allow a new community of developers to use the CDM in their projects. Common Domain Model into Open Source at FINOS ​ Read more about CDM's journey into open source, project contribution guidelines, principles, and frequently asked questions. Barclays demonstration of interest rate swap processing using the Common Domain Model (CDM) ​ In this recording, Barclays introduces a prototype for processing interest rate swaps using the common domain model. Starting with how the post-trade industry in capital markets has evolved over time, resulting in procedural inefficiencies that are complex, duplicative, and costly to maintain. The common domain model covers processes, events, and data, and Barclays prototype aims to showcase the potential of this new standard in revolutionizing the post-trade industry. ISLA, ICMA & ISDA Appoint FINOS for CDM Repository ​ On Thursday, September 8th, 2022, three leading organizations in the financial industry, International Securities Lending Association (ISLA), International Capital Market Association (ICMA), and International Swaps and Derivatives Association (ISDA), made a major announcement appointing FINOS to provide a repository for the Common Domain Model (CDM) with the aim of fostering growth in the open-source community. 2022 Open Source in Finance Forum New York Keynote Panel: Common Domain Model (CDM) ​ At the keynote session of the 2022 Open Source in Finance Forum New York, a panel of industry leaders including Adrian Dale of ISLA, Alan Milligan of ISDA, and Georgina Jarrett, joined moderator Ffion Acland of Goldman Sachs to delve into the exciting topic of trade association collaboration, open sourcing, and the creation of a common domain for the market, built by the market. Looking Backwards & Forwards at CDM: History of the Common Domain Model… ​ The first portion of the one-hour CDM presentation at the 2022 NYC Open Source in Finance Forum featured a panel of distinguished industry leaders, including Ian Sloyan of ISDA, David Shone of ISLA, Gabriel Callsen of ICMA, and Amy Caruso of ISDA. The panel came together to provide a comprehensive overview of the history of Common Domain Model (CDM) and its evolution. The experts shared their insights on where CDM has come from and where it's headed in the future, offering valuable perspectives on the role of CDM in shaping the future of finance. Implementing CDM: How is it Done, Why is it Beneficial to Financial Markets Infrastructure? ​ The second half of the one-hour CDM presentation at the Open Source in Finance Forum (OSFF) in New York was dedicated to exploring the potential of Common Domain Model (CDM) in market infrastructure. A panel of experts, including Jon Nance of Axoni, Dianne Boyle of Symbiont, Sunil Challa of Credit Suisse, and Eleonora Acuna of ISDA, came together to delve into the possibilities of CDM in the real world. They discussed the practical applications and potential of CDM, offering valuable insights into the future of this exciting technology. FINOS on what’s next for CDM and open source trends ​ On January 11th, 2023, FINADIUM sat down with Gabriele Columbro, the Executive Director at FINOS and General Manager of the Linux Foundation Europe, to discuss the exciting world of open source trends in financial services. During the conversation, Gabriele shared his insights on what to expect in the coming months and years and provided a broad overview of the overarching open source trends in the financial services industry. ISDA Digital Reporting ​ ISDA's Digital Regulatory Reporting provides a comprehensive solution for translating amended rules into machine-executable open-source code. This allows financial firms to access a standardized interpretation of the requirements and integrate them directly into their systems, streamlining their regulatory reporting processes and reducing the risk of compliance errors. With ISDA's Digital Regulatory Reporting, financial institutions can stay ahead of the regulatory curve and easily implement the latest industry standards and requirements."
CDM_Collateral_Working_Group.txt,"Main Menu CDM Collateral Working Group Version: 5.13.0 On this page CDM Collateral Working Group Common Domain Model Collateral Start-Up Guide ​ ISDA has also launched the Get Started with the CDM for Collateral Guide! You can now access a wealth of resources and tutorials on CDM for collateral management on the CDM-Collateral Initiatives page . Overview ​ The Collateral Working Group plays a pivotal role in the CDM ecosystem by providing a robust framework for harmonizing data and processes related to collateral flows and documentation. Meetings ​ Email to be added to the meeting invites directly, or find the meeting in the . 2024 Roadmap ​ ​ To subscribe to the collateral workin group mailing list and stay updated on meetings and agenda, please send an email to . After sending the email, you will receive a confirmation message. Reply to confirm your subscription. To view meeting notes and agendas, view our current and past GitHub Meeting Issues."
The_Common_Domain_Model.txt,"Main Menu The Common Domain Model Version: 5.13.0 The Common Domain Model There are seven modelling dimensions to the CDM, which are detailed in the following sections: product-model event-model legal-agreements process-model reference-data-model mapping namespace In each section, selected examples of model definitions are used as illustrations to help explain each dimension and include, where applicable, data samples to help demonstrate the structure. The CDM is expressed in a language called the Rosetta DSL. All the language components used by the CDM including types, functions and annotations are described in the Rosetta DSL Documentation . The complete model definition, including descriptions and other details can be viewed in the Textual Browser in the CDM Portal ."
CDM_Java_Distribution_Guidelines.txt,"Main Menu CDM Java Distribution Guidelines Version: 5.13.0 On this page CDM Java Distribution Guidelines This section provides directions for downloading and using the Java version of CDM. Topics covered are listed below: Prerequisites Introduction Setting Up Google's Guice Injector Generating Global Keys and Qualifications Validating the CDM instance Prerequisites Java SDK 8 or higher Introduction The CDM in Java is built using maven and is published to Maven Central. Setup In order to use the CDM in a Maven project, the following dependency needs to be added to the project pom.xml: < dependency > < groupId > org.finos.cdm </ groupId > < artifactId > cdm-java </ artifactId > < version > LATEST </ version > </ dependency > The CDM model objects are classified into namespaces (cdm.base, cdm.base.staticdata, etc). These namespaces translate into Java packages with the same name, with each package containing a package-info file. The CDM uses builder pattern for each of the pojos. The distribution ships with the json to java object serialisers. NOTE: All current CDM dependencies are available in Maven Central. CDM releases prior to version 4.0.0 can be found in the ISDA repository: https://europe-west1-maven.pkg.dev/production-208613/isda-maven . The dependencies of CDM releases prior to version 4.0.0 can be found in the REGnosys repository: https://europe-west1-maven.pkg.dev/production-208613/public-maven . Add the following snippet to the <repositories> section of your project pom.xml : < repositories > <!-- remove references to REGnosys Jfrog --> < repository > < id > isda-maven </ id > < url > https://europe-west1-maven.pkg.dev/production-208613/isda-maven </ url > < releases > < enabled > true </ enabled > </ releases > < snapshots > < enabled > false </ enabled > </ snapshots > </ repository > < repository > < id > public-maven </ id > < url > https://europe-west1-maven.pkg.dev/production-208613/public-maven </ url > < releases > < enabled > true </ enabled > </ releases > < snapshots > < enabled > false </ enabled > </ snapshots > </ repository > <!-- existing contents --> </ repositories > Setting Up Google's Guice Injector CDM uses Google's Guice as a dependency manager. Injector is the core of Guice that contains the whole object graph (context). The first step is to initialise the injector. There are two options: Initialising the Injector, Option 1: Using provided CdmRuntimeModule ​ The CDM java distribution comes with a pre-built CDM module that can be used to create an injector. It provides bindings to required classes (ModelObjectValidator and QualifyFunctionFactory) as well as binding in implementations for several CDM functions such as Abs, Sum Injector injector = Guice.createInjector(new CdmRuntimeModule())); Initialising the Injector, Option 2: Build your own Module ​ To build a custom injector that is not based on the CDM's runtime module, first create a Guice module with a minimum of the two bindings shown belows: public class GenericModule extends AbstractModule { @Override protected void configure() { bind(ModelObjectValidator.class).to(RosettaTypeValidator.class); bind(QualifyFunctionFactory.class).to(QualifyFunctionFactory.Default.class); } } Once this module has been built it can be used to create the custom injector. Injector injector = Guice.createInjector(new GenericModule())); Generating Global Keys and Qualifications Within the model any data object marked with metadata key will have a Global Key generated when that data object is populated. These Global Keys are automatically generated using hash algorithms. The model objects can be post-processed with Global Keys and qualified by using the injector created in the previous step to run the code shown below: Contract cdmInstance = buildCdmInstance(); Contract.ContractBuilder builder = cdmInstance.toBuilder(); keyProcessor.runProcessStep(Contract.class, builder); Contract updatedCdmInstance = builder.build(); Validating the CDM instance In order to validate the CDM instance, it is necessary to create a RosettaTypeValidator and post process the instance as follows: RosettaTypeValidator validator = injector.getInstance(RosettaTypeValidator.class); ValidationReport validationReport = validator.runProcessStep(cdmInstance.getClass(), cdmInstance.toBuilder()); if (validationReport.success()) { List<ValidationResult<?>> validationResults = validationReport.validationFailures(); } If the validation is unsuccessful then the validation results object will contain the list of all the validation failures."
Overview_of_the_FINOS_CDM.txt,"Main Menu Overview of the FINOS CDM Version: 5.13.0 On this page Overview of the FINOS CDM Continuous Integration: What is the FINOS CDM The FINOS Common Domain Model (CDM) is a standardised, machine-readable and machine-executable blueprint for how financial products are traded and managed across the transaction lifecycle. It is represented as a domain model and distributed in open source. For an overview of the Common Domain Model, a comparative analysis with FpML, an exploration of the CDM's historical development and events, as well as insights into its further applications, including its role in the ecosystem and support for smart contract technology, we recommend reviewing the CDM Overview deck . ISDA’s Digital Regulatory Reporting (DRR) solution leverages the open-source Common Domain Model (CDM) to convert industry-agreed interpretations of new or amended regulatory reporting rules into clear, machine-executable code. This approach enhances implementation efficiency and reduces costs. Institutions contributing to the development of the ISDA DRR include (but are not limited to) those listed on ISDA’s Digital Regulatory Reporting Page . ISDA has also launched the Get Started with the CDM for Collateral Guide! You can now access a wealth of resources and tutorials on CDM for collateral management on the CDM-Collateral Initiatives page . If you’re interested in the Common Domain Model (CDM), please complete the CDM Interest Form to join our mailing list. By signing up, you’ll receive updates on CDM initiatives, meeting agendas, and other working group activities. Purpose ​ A single, digital processing standard for trade events and actions enhances financial markets' operational efficiency in several ways: Enables inter-operability and straight-through processing across firms, solutions and platforms, reducing the need for reconciliation caused by variations in how each firm records trade lifecycle events. Accelerates financial technology innovation by providing a common, readily operational foundation for how technologies like distributed ledger, smart contracts, cloud computing, and artificial intelligence can be applied to financial markets. Delivers better regulatory oversight , promotes transparency and alignment between regulators and market participants and enables consistency in regulatory reporting, by providing a standard representation of trade data and supporting machine executable reporting requirements. For further information about the CDM and its applications, please consult the CDM section of the FINOS website or contact FINOS directly at cdm@lists.finos.org . Design Principles ​ To support these objectives, the CDM is built according to a set of design principles that include the following concepts: Normalisation through abstraction of common components Composability where objects are composed and qualified from the bottom up Mapping to existing industry messaging formats Embedded logic to represent industry processes Modularisation into logical layers These design principles are further detailed in the design-principles section of the CDM documentation. Governance ​ The CDM governance framework regulates the development of the CDM in open source. Scope ​ The CDM covers OTC derivatives, cash securities, securities financing, commodities, and can expand to include other Capital Markets products and Asset Classes. CDM 2024 Roadmap ​ Below is the full roadmap as ratified by the Steering WG in Jan 2024, subject to change as priorities evolve. The latest CDM roadmap of expected contributions sponsored by the presently participating trade associations: ICMA, ISDA and ISLA can be found under Roadmap.md . Releases can be tracked on the CDM Releases page. CDM Components The CDM is made of three sets of components , as laid-out in the FINOS CDM components diagram below: The FINOS CDM Distribution (in blue ) The Rosetta DSL (in grey ) CDM Applications (in green ) FINOS CDM Distribution ​ The FINOS CDM distribution is openly accessible to all industry participants, subject to the FINOS CDM open source licence. This distribution is fully downloadable. The FINOS CDM distribution comprises three main sets of components: Model definition , which corresponds to the model as expressed in the Rosetta DSL and contained into a set of .rosetta files organised as namespaces . The primary dimensions of the model are listed below and further described in the common-domain-model of the documentation. Product Event Legal Agreement Process Reference Data Mapping (Synonym) Executable code distribution , automatically generated from the model definitions expressed in the Rosetta DSL using available code generators . Once a code generator is implemented for a particular language, the corresponding code generation is included as part of the CDM build and release process, allowing the CDM to be automatically distributed in that language going forward. Default implementation , comprising manually-written code (in Java) which, combined with the auto-generated code, provides a complete implementation of the model. This hand-written code is distributed together with the CDM to facilitate adoption by firms, which can directly use the CDM distribution to set-up and test an implementation. The default implementation can be used in its original state or be disabled or extended by industry participants in their implementations. For example, the default implementation uses the de-facto Java hash function to support cross-referencing in the CDM, but firms may elect to use an alternative implementation. Note: Only the Java executable code distribution is complete: i.e. it represents the entire CDM as defined in Rosetta (plus any associated default implementation). Other distributions may only capture parts of the model: for instance, the Scala and TypeScript distributions include the complete data model and function specifications, but not the functions' executable code. Rosetta DSL ​ The CDM is written in a Domain-Specific Language (DSL) called the Rosetta DSL , that comprises a language (i.e. syntax, semantics and rules) and code generators . The language includes one default code generator into java . To facilitate adoption and implementation of the CDM by the community of industry participants, the Rosetta DSL is available in open source under an Apache 2.0 license. This allows industry participants to write and share code generators into any other languages. Note: All the language components, their syntax and purpose are detailed in the Rosetta DSL Documentation . The documentation also describes the mechanism to write and use code generators. CDM Applications ​ An ecosystem of CDM-based application components from software providers exists in order to support the adoption of CDM and the implementation of CDM-based production systems by industry participants. These applications may be open source software or licensed under commercial terms. In particular: Rosetta is a Software Development Kit (SDK or dev-kit ) for the Rosetta DSL, that provides the cumminity with a free and easy way to contribute code to the CDM. Please refer to the Rosetta Documentation for more details. Note: The CDM Portal and Rosetta have been developed by technology firm REGnosys . FINOS encourages the adoption of CDM by software providers but does not endorse any CDM application component. Using the CDM (Java) The Java distribution of the CDM is designed to be built and used with Maven. It depends on some open source java artifacts which are freely available from an artifact repository. Maven can be configured to use this repository using the repository settings contained in the settings.xml file in the CDM jar. For more details, please follow the CDM Java Distribution Guidelines ."
Event_Model.txt,"Main Menu Event Model Version: 5.13.0 On this page Event Model The CDM event model provides data structures to represent the lifecycle events of financial transactions . A lifecycle event occurs when a transaction goes through a state transition initiated either by one or both trading parties, by contractual terms, or by external factors. For example, the execution of a trade is the initial event which results in the state of an executed trade. Subsequently, one party might initiate an allocation, both parties might initiate an amendment to a contractual agreement, or a default by an underlying entity on a Credit Default Swap would trigger a settlement according to defined protection terms. Examples of lifecycle events supported by the CDM Event Model include the following: Trade execution and confirmation Clearing Allocation Settlement (including any future contingent cashflow payment) Exercise of options The representation of lifecycle events in the CDM is based on the following design principles: A lifecycle event describes a state transition . There must be different before/after trade states based on that lifecycle event. State transitions are functional and composable . The CDM specifies the entire functional logic to transition from one state to another. The state transition logic of all in-scope events is obtained by composition from a small set of functional building blocks. The history of the trade state can be reconstructed at any point in the trade lifecycle. The CDM implements a lineage between states as the trade goes through state transitions. The product underlying the transaction remains immutable . Automated events, for instance resets or cashflow payments, do not alter the product definition. Lifecycle events negotiated between the parties that give rise to a change in the trade economics generate a new instance of the product or trade as part of that specific event. The state is trade-specific , not product-specific (i.e. the CDM is not an asset-servicing model). The same product may be associated to infinitely many trades, each with its own specific state, between any two parties. To represent a state transition, the event model is organised around four main components: Trade state represents the state in the lifecycle that the trade is in, from execution to settlement and maturity. Primitive operator is the functional building block that is used to compose business events. Each operator describes a fundamental change to the state of a trade going from a before state to an after state and is parameterised by a primitive instruction input. Business event represents a lifecycle event affecting one or more trades as a composite of primitive instructions. A business event can comprise several instructions, each consisting of a set of primitive instructions applied to a single trade state (before). The resulting trade state (after) can be multiple. Workflow represents a set of actions or steps that are required to trigger a business event. The below diagram illustrates the relationship between these components. Each of them is described in the next four sections. Trade State A trade state is defined in CDM by the TradeState data type and represents the state of a trade at each stage in its lifecycle. With each trade creation or modification event, a new TradeState instance is created. Chaining together the sequence of TradeState instances then recreates the path each trade took within its lifecycle. TradeState is a foundational data type in the CDM Event Model as it represents the input and output of any state transition. Therefore, all trade-related information that can change throughout the trade lifecycle are representing within TradeState . type TradeState: [metadata key] [rootType] trade Trade (1..1) state State (0..1) resetHistory Reset (0..*) transferHistory TransferState (0..*) While many different types of events may occur through the trade lifecycle, the trade , state , resetHistory and transferHistory attributes are deemed sufficient to describe all of the possible (post-trade) states which may result from lifecycle events. The Trade data type contains the tradable product, which defines all of the economic terms of the transaction as agreed between the parties. The Trade , State , Reset and Transfer data types that are utilised within TradeState are all detailed in the sections below. Trade ​ The Trade data type defines the outcome of a financial transaction between parties, where the terms are primarily reflected in the tradable product. Additionally, Trade includes attributes such as the trade date, transacting parties, and settlement terms. Some attributes, such as the parties, may already be defined in a workflow step or business event and can simply be referenced in Trade . type Trade: [metadata key] tradeIdentifier TradeIdentifier (1..*) tradeDate date (1..1) [metadata id] tradeTime TimeZone (0..1) [metadata id] tradableProduct TradableProduct (1..1) party Party (0..*) partyRole PartyRole (0..*) executionDetails ExecutionDetails (0..1) contractDetails ContractDetails (0..1) clearedDate date (0..1) [deprecated] collateral Collateral (0..1) account Account (0..*) [deprecated] Note: Attributes within Trade and ContractDetails incorporate elements from FpML's trade confirmation view, whereas the TradableProduct data type corresponds to FpML's pre-trade view. The TradableProduct data type is further detailed in the tradable-product section of the documentation. Additionally, Trade supports the representation of specific execution or contractual details via the executionDetails and contractDetails attributes. ExecutionDetails ​ The ExecutionDetails data type represents details applicable to trade executions and includes attributes that describe the execution venue and execution type. Not all trades will have been 'executed', such as those created from a Swaption Exercise event. In those cases, the executionDetails attributes on Trade is expected to be empty. type ExecutionDetails: [metadata key] executionType ExecutionTypeEnum (1..1) executionVenue LegalEntity (0..1) packageReference IdentifiedList (0..1) condition ExecutionVenue: if executionType = ExecutionTypeEnum -> Electronic then executionVenue exists ContractDetails ​ ContractDetails are only applicable to trades on contractual products and are typically provided at or prior to trade confirmation. type ContractDetails: [metadata key] documentation LegalAgreement (0..*) governingLaw GoverningLawEnum (0..1) [metadata scheme] State ​ The State data type defines the state of a trade at a point in the Trade's life cycle. Trades have many state dimensions, all of which are represented here. For example, states useful for position keeping are represented alongside those needed for regulatory reporting. type State: closedState ClosedState (0..1) positionState PositionStatusEnum (0..1) When a trade is closed, it is necessary to record that closure as part of the trade state. For instance in a full novation scenario, the initial state is a single TradeState and the resulting state is two TradeState . The first resulting TradeState represents a new contract, which is the same as the original but where one of the parties has been changed, and the second resulting TradeState is the original contract, now marked as closed . The ClosedState data type (enclosed within State ) captures this closed state and defines the reason for closure. enum ClosedStateEnum: Allocated Cancelled Exercised Expired Matured Novated Terminated Reset ​ In many cases, a trade relies on the value of an observable which will become known in the future: for instance, a floating rate observation at the beginning of each period in the case of a Interest Rate Swap, or the equity price at the end of each period in an Equity Swap. This reset information is captured by the Reset data type and associated to the trade state. While the reset information is trade-specific, the observation itself is provided by the relevant market data provider independently of any specific trade. Such observation is captured by the Observation data type. Both the observedValue (in Observation ) and the resetValue (in Reset ) attributes are specified as a Price type. In the trade, the resettable value must be associated to a variable price attribute. It typically represents a number that is directly used to compute transfer amounts like cashflows. In addition to the observation value, a reset specifies the date from which the resettable value becomes applicable in the trade's context, which could be different from the observation date if some observation lag applies. Depending on the trade's economic properties, a reset may also depend on several observation values based on some aggregation method - e.g. a compounded interest rate based on daily fixings. type Reset: [metadata key] resetValue Price (1..1) resetDate date (1..1) rateRecordDate date (0..1) observations Observation (1..*) [metadata reference] averagingMethodology AveragingCalculation (0..1) type Observation: [rootType] [metadata key] observedValue Price (1..1) observationIdentifier ObservationIdentifier (1..1) Transfer ​ A transfer is a multi-purpose object that represents the transfer of any asset, including cash, from one party to another. The Transfer object is associated to an enumeration to qualify the status that the transfer is in, from instruction to settlement or rejection. type TransferState: [metadata key] [rootType] transfer Transfer (1..1) transferStatus TransferStatusEnum (0..1) type Transfer extends TransferBase: settlementOrigin SettlementOrigin (0..1) resetOrigin Reset (0..1) transferExpression TransferExpression (1..1) type TransferBase: identifier Identifier (0..*) [metadata scheme] quantity NonNegativeQuantity (1..1) observable Observable (0..1) payerReceiver PartyReferencePayerReceiver (1..1) settlementDate AdjustableOrAdjustedOrRelativeDate (1..1) Primitive Operator ​ Primitive operators are functional building blocks used to compose business events . Each primitive operator describes a fundamental state transition that applies to a trade. There are nine fundamental operations on trade state. Other than split and execution, they each impact separate attributes of a trade state and are therefore independent of each other. execution: instantiates a new trade. quantity change: changes the quantity (and/or price) of a trade terms change: changes the terms of the product of a trade party change: changes a party on a trade exercise: exercises an option embedded in a trade contract formation: associates a legal agreement to a trade reset: changes a trade's resettable value based on an observation transfer: transfers some asset (cash, security, commodity) from one party to another split: splits a trade into multiple identical trades Primitive Function ​ A primitive operator is represented by a primitive function that takes a before trade state as input and returns an after trade state as output, both of type TradeState . The only exceptions to this rule are: execution, for which there is no before state since its purpose is to instantiate a new trade, and split, which results in multiple trade states as copies of the original trade. All primitive functions are prefixed by Create_ followed by the name of the primitive operator. The business logic of primitive functions is fully implemented. An example of primitive function, for the PartyChange primitive, is illustrated below. func Create_PartyChange: inputs: counterparty Counterparty (1..1) ancillaryParty AncillaryParty (0..1) partyRole PartyRole (0..1) tradeId TradeIdentifier (1..*) originalTrade TradeState (1..1) output: newTrade TradeState (1..1) Primitive Instruction ​ Primitive functions take additional inputs alongside the before trade state to specify the parameters of the state transition. Each primitive operator is associated to a primitive instruction data type that contains the function's required parameters as attributes - illustrated below using the same PartyChange example. type PartyChangeInstruction: counterparty Counterparty (1..1) ancillaryParty AncillaryParty (0..1) partyRole PartyRole (0..1) tradeId TradeIdentifier (1..*) The PrimitiveInstruction data type allows to build composite primitive instructions and therefore compose primitive operators. This data type contains one instruction attribute for each of the possible nine primitive instruction types - aligned onto the nine fundamental primitive operators. type PrimitiveInstruction: contractFormation ContractFormationInstruction (0..1) execution ExecutionInstruction (0..1) exercise ExerciseInstruction (0..1) partyChange PartyChangeInstruction (0..1) quantityChange QuantityChangeInstruction (0..1) reset ResetInstruction (0..1) split SplitInstruction (0..1) termsChange TermsChangeInstruction (0..1) transfer TransferInstruction (0..1) Primitive Composition ​ The separation between the before trade state and primitive instructions allows to compose primitive operators. Primitive operators can be chained by applying a composite primitive instruction to a single trade state, as represented in the diagram below. Note: When a primitive instruction is composite, interim trade states will be created when executing each primitive operator. These interim trade states may not correspond to any actual business outcome (only the final after trade state does), so implementors will usually choose not to persist them. The Create_TradeState function performs such composition of primitive operators. It takes a single trade state and a composite primitive instruction as inputs and returns a single trade state. The before trade state input is optional, in which case a new execution must be specified in the instructions. This function applies each of the primitive operators (other than split) to the trade state in the order listed in the primitive operator section. Apart from execution which, when present, must always be applied first, the order does not affect the outcome because each primitive operator impacts a different part of the trade state. func Create_TradeState: inputs: primitiveInstruction PrimitiveInstruction (0..1) before TradeState (0..1) output: after TradeState (1..1) Special Case: Split ​ Split is a special case of primitive operator. It is used in many lifecycle events that require a trade to be copied, such as in clearing or allocation scenarios. In itself, it does not change the state of a trade - it just creates identical copies Contrary to other operators, it outputs multiple trade states Order matters: when present, a split must be executed before other operators can be applied to its multiple output Like other primitive operators, split is associated to a split function and a split instruction. But unlike other operators, the split function cannot be executed in the Create_TradeState function because it returns a multiple output. Instead, a split instruction provides a breakdown of primitive instructions to apply to each post-split trade state. For example, an allocation instruction would be specified as a split breakdown, each with a quantity change instructions to divide the initial block trade into smaller pieces, and then a party change instruction to assign each piece to a different legal entity related to the executing party. The split function iterates on each element of the breakdown and applies the corresponding primitive instruction to each copy of the original trade using the Create_TradeState function. The size of that breakdown directs the size of the split. type SplitInstruction: breakdown PrimitiveInstruction (1..*) func Create_Split: inputs: breakdown PrimitiveInstruction (1..*) originalTrade TradeState (1..1) output: splitTrade TradeState (1..*) add splitTrade: breakdown extract Create_TradeState(item, originalTrade) Examples of how primitive operators work are illustrated below. Examples of Primitive Operators ​ Execution Primitive ​ The first step in instantiating a transaction between two parties in the CDM is an execution . In practice, this execution represents the conclusion of a pre-trade process, which may be a client order that gets filled or a quote that gets accepted by the client. However, the CDM event model only covers post-trade lifecycle events so assumes that a trade gets instantiated ""from scratch"" at execution. Therefore, the execution function does not take any before state as input and all the trade details are contained in the execution instruction input. func Create_Execution: inputs: instruction ExecutionInstruction (1..1) output: execution TradeState (1..1) type ExecutionInstruction: product Product (1..1) priceQuantity PriceQuantity (1..*) counterparty  Counterparty (2..2) ancillaryParty AncillaryParty (0..*) parties Party (2..*) partyRoles PartyRole (0..*) executionDetails ExecutionDetails (1..1) tradeDate date (1..1) [metadata id] tradeTime TimeZone (0..1) [metadata id] tradeIdentifier TradeIdentifier (1..*) collateral Collateral (0..1) Contract Formation Primitive ​ Once an execution is confirmed, a legally binding contract is signed between the two executing parties and a contract formation associates a legal agreement to the transaction. The contract formation primitive function represents the transition of the trade state to a legally binding legal agreement after the trade is confirmed. The function takes an existing trade state (typically, but not necessarily, an execution) as input and returns a trade state output containing the contract details. The ContractDetails object can reference some higher-order legal documentation governing the transaction - usually a master agreement . This legal documentation information is provided in the contract formation instruction input. func Create_ContractFormation: inputs: instruction ContractFormationInstruction (1..1) execution TradeState (1..1) output: contractFormation TradeState (1..1) type ContractFormationInstruction: legalAgreement LegalAgreement (0..*) Because a transaction may change through some lifecycle events before getting confirmed, the contract formation primitive is separated from the execution primitive so that it can be invoked appropriately depending on the scenario. E.g. in an allocation, the trade would first get split into sub-accounts as designated by one of the executing parties, before a set of legally binding contracts is signed with each of those sub-accounts. A contract formation may not even follow an execution and could occur as part of later lifecycle events. E.g. in a novation scenario, a new contract will need to be instantiated with the step-in party and the right legal agreement associated to that trade. In other cases, the execution and confirmation happen in one go and a contract is instantiated immediately. Such contract instantiation scenario can be represented using a compositive primitive instruction that comprises both an execution and a contract formation instruction and applies to a null trade state. Reset Primitive ​ The reset function associates a reset object to the trade state. The reset function creates an instances of the Reset data type and adds it to the resetHistory attribute of a given TradeState . The reset instruction specifies the payout that is subject to the reset, via a reference. A reset does not modify the underlying Trade object. func Create_Reset: inputs: instruction ResetInstruction (1..1) tradeState TradeState (1..1) output: reset TradeState (1..1) type ResetInstruction: payout Payout (1..1) [metadata reference] rateRecordDate date (0..1) resetDate date (1..1) Transfer Primitive ​ The transfer primitive function takes a TransferState object as transfer instruction input and adds it to the transferHistory attribute of the TradeState . By design, the CDM treats the reset and the transfer primitive operators separately because there is no one-to-one relationship between reset and transfer. Many transfer events are not tied to any reset: for instance, the currency settlement from an FX spot or forward transaction. Conversely, not all reset events generate a cashflow: for instance, the single, final settlement that is based on all the past floating rate resets in the case of a compounding floating zero-coupon swap. type TransferInstruction: transferState TransferState (0..*) Business Event ​ Business events are built according to the following principles: A business event is specified functionally by composing primitive operators , each of which representing a fundamental change to the trade state and described by a primitive instruction. Business event qualification is inferred from those primitive components and, in some relevant cases, from an additional intent qualifier associated with the business event. The inferred value is populated in the eventQualifier attribute. type BusinessEvent extends EventInstruction: [metadata key] [rootType] eventQualifier string (0..1) after TradeState (0..*) type Instruction: [rootType] primitiveInstruction PrimitiveInstruction (0..1) before TradeState (0..1) [metadata reference] The only mandatory attributes of a business event are: The event instruction. This is a list of Instruction objects, each representing a composite primitive instruction applied to a single (before) trade state. This attribute is of multiple cardinality, so a business event may impact multiple trades concurrently and result in multiple (after) trade states. The event date. The time dimension has been purposely ommitted from the event's attributes. That is because, while a business event has a unique date, several time stamps may potentially be associated to that event depending on when it was submitted, accepted, rejected etc, all of which are workflow considerations. Note: The primitives attribute corresponds to a previous implementation of the primitive operators, now deprecated but maintained for backward-compatibility purposes. Because some implementations rely on this former mechanism instead of the new primitive instruction mechanism, the lower bound of the instruction attribute's cardinality is 0 instead of 1. It will be updated to 1 once the former primitive mechanism is fully retired. Event Composition ​ An example composition of primitive instructions to represent a complete lifecycle event is shown below. The event represents the partial novation of a contract, which comprises the following: a split primitive a quantity change primitive applied to each post-split trade, where the total quantity should match the quantity of the original trade and none of the quantities is 0. A quantity of 0 for the remaining trade would result in a termination and represent a full novation . a party change primitive applied to the post-split trade whose quantity corresponds to the novated quantity. ""primitiveInstruction"" : { ""split"" : { ""breakdown"" : [ { ""partyChange"" : { ""counterparty"" : { ""partyReference"" : { ""value"" : { ""name"" : { ""value"" : ""Bank Z"" }, ""partyId"" : [ { ""identifier"" : { ""value"" : ""LEI3RPT0003"" }, ""identifierType"" : ""LEI"", } ] } }, ""role"" : ""PARTY_1"" }, ""tradeId"" : [ { ""assignedIdentifier"" : [ { ""identifier"" : { ""value"" : ""LEI3RPT0003DDDD"" }, ""identifierType"" : ""UNIQUE_TRANSACTION_IDENTIFIER"" } ], ""issuer"" : { ""value"" : ""LEI3RPT0003"" }, } ] }, ""quantityChange"" : { ""change"" : [ { ""quantity"" : [ { ""value"" : { ""amount"" : 5000, ""unitOfAmount"" : { ""currency"" : { ""value"" : ""USD"" } } } } ] } ], ""direction"" : ""REPLACE"" } }, { ""quantityChange"" : { ""change"" : [ { ""quantity"" : [ { ""value"" : { ""amount"" : 8000, ""unitOfAmount"" : { ""currency"" : { ""value"" : ""USD"" } } } } ] } ], ""direction"" : ""REPLACE"" } } ] } } A business event is atomic , i.e. its primitive components cannot happen independently. They either all happen together or not at all. In the above partial novation example, the existing trade between the original parties must be downsized at the same time as the trade with the new party is instantiated. Trade compression is another example, that involves multiple before trades being downsized or terminated and new trades being created between multiple parties, all of which must happen concurrently. Event Qualification ​ The CDM qualifies lifecycle events as a function of their primitive components rather than explicitly declaring the event type. The CDM uses the same approach for event qualification as for product qualification and is based on a set of Event Qualification functions. These functions are identified with a [qualification BusinessEvent] annotatation. Event Qualification functions apply a taxonomy-specific business logic to identify if the state-transition attributes values, which are embedded in the primitive event components, match the specified criteria for the event named in that taxonomy. Like Product Qualification functions, the Event Qualification function name is prefixed with the word Qualify_ followed by the taxonomy name. The CDM uses the ISDA taxonomy V2.0 leaf level to qualify the event. 23 lifecycle events have currently been qualified as part of the CDM. One distinction with the product approach is that the intent qualification is also deemed necessary to complement the primitive event information in certain cases. To this effect, the Event Qualification function allows to specify that when present, the intent must have a specified value, as illustrated by the below example. func Qualify_Termination: [qualification BusinessEvent] inputs: businessEvent BusinessEvent (1..1) output: is_event boolean (1..1) alias primitiveInstruction: businessEvent -> instruction -> primitiveInstruction only-element alias transfer: TransfersForDate( businessEvent -> after -> transferHistory -> transfer, businessEvent -> eventDate ) only-element set is_event: businessEvent -> intent is absent and (primitiveInstruction -> quantityChange only exists or (primitiveInstruction -> quantityChange, primitiveInstruction -> transfer) only exists) and (QuantityDecreasedToZero(businessEvent -> instruction -> before, businessEvent -> after) = True) and (businessEvent -> after -> state -> closedState -> state all = ClosedStateEnum -> Terminated) If all the statements above are true, then the function evaluates to True. In this case, the event is determined to be qualified as the event type referenced by the function name. The output of the qualification function is used to populate the eventQualifier attribute of the BusinessEvent object, similar to how product qualification works. An implementation of the CDM would call all of the Event Qualification functions following the creation of each event and then insert the appropriate value or provide an exception message. Note: The type of the eventQualifier attribute in BusinessEvent , called eventType , is a meta-type that indicates that its value is meant to be populated using some functional logic. That functional logic must be represented by a qualification function annotated with [qualification BusinessEvent] , as in the example above. This mechanism is further detailed in the Rosetta DSL documentation. Intent ​ The intent attribute is an enumeration value that represents the intent of a particular business event. It is used in the event qualifcation logic in cases where the primitive composition is not sufficient to uniquely infer a lifecycle event. The description of each possible enumeration value provides an illustration of how this attribute is used. enum EventIntentEnum: Allocation CashFlow Clearing Compression ContractFormation ContractTermsAmendment CorporateActionAdjustment CreditEvent Decrease EarlyTerminationProvision Increase IndexTransition NotionalReset NotionalStep Novation ObservationRecord OptionExercise OptionalExtension OptionalCancellation PortfolioRebalancing PrincipalExchange Reallocation Repurchase Lineage ​ The BusinessEvent data type implements lineage by tying each trade state to the trade state(s) that came before it in the lifecyle. The before attribute in each instruction is included as a reference using the [metadata reference] annotation. By definition the primitive instruction applies to a trade state that already exists. By contrast, the after trade state in the business event provides a full definition of that object. That trade state is occurring for the first time and as triggered by the application of the primitive operators specified in the business event. The after trade state is optional because it may be latent while the business event is going through some acceptance workflow. Other Misc. Information ​ Other selected attributes of a business event are explained below. The effective date is optional as it is not applicable to certain events (e.g. observations), or may be redundant with the event date. The event qualifier attribute is derived from the event qualification features. This is further detailed in the event qualification section. Workflow The CDM provides support for implementors to develop workflows to process transaction lifecycle events. A workflow represents a set of actions or steps that are required to trigger a business event, including the initial execution or contract formation. A workflow is organised into a sequence in which each step is represented by a workflow step . A workflow may involve multiple parties in addition to the parties to the transaction, and may include automated and manual steps. A workflow may involve only one step. The CDM supports a workflow's audit trail by providing lineage from one step to another in that workflow. type WorkflowStep: [metadata key] [rootType] businessEvent BusinessEvent (0..1) counterpartyPositionBusinessEvent CounterpartyPositionBusinessEvent (0..1) proposedEvent EventInstruction (0..1) rejected boolean (0..1) approval WorkflowStepApproval (0..*) previousWorkflowStep WorkflowStep (0..1) [metadata reference] nextEvent EventInstruction (0..1) messageInformation MessageInformation (0..1) timestamp EventTimestamp (1..*) eventIdentifier Identifier (1..*) action ActionEnum (0..1) party Party (0..*) account Account (0..*) lineage Lineage (0..1) [deprecated] creditLimitInformation CreditLimitInformation (0..1) workflowState WorkflowState (0..1) The different attributes of a workflow step are detailed in the sections below. Workflow Step Business Event ​ This attribute specifies the business event that the workflow step is meant to generate. It is optional because the workflow may require a number of interim steps before the state-transition embedded within the business event becomes effective, therefore the business event does not exist yet in those steps. The business event attribute is typically associated with the final step in the workflow. Proposed Event ​ This attribute specifies the inputs required to perform the event's state transition and comprises a subset of the attributes of the business event itself. It is optional because it is only required for all pre-acceptance workflow steps. Once accepted, the business event is entirely represented, including its instructions, by the businessEvent attribute. Validation components are in place to check that the businessEvent and proposedEvent attributes are mutually exclusive. type EventInstruction: intent EventIntentEnum (0..1) corporateActionIntent CorporateActionTypeEnum (0..1) eventDate date (0..1) effectiveDate date (0..1) packageInformation IdentifiedList (0..1) instruction Instruction (0..*) Next Event ​ Parties sometimes pre-agree a follow-on event that is meant to be executed after the current event completes, but separately from it. A typical scenario is an execution that specifies that the trade is intended for clearing at a pre-specified clearing house. In this case, the parameters of the next event are known in advance need to be agreed between the parties as part of the current event. The parameters of this next event are represented by an EventInstruction data type included in the workflow process. Previous Workflow Step ​ This attribute, which is provided as a reference, defines the lineage between steps in a workflow. The result is an audit trail for a business event, which can trace the various steps leading to the business event that was triggered. Action ​ The action enumeration qualification specifies whether the event is a new one or a correction or cancellation of a prior one, which are trade entry references and not reflective of negotiated changes to a contract. Message Information ​ The messageInformation attribute defines details for delivery of the message containing the workflow steps. type MessageInformation: messageId string (1..1) [metadata scheme] sentBy string (0..1) [metadata scheme] sentTo string (0..*) [metadata scheme] copyTo string (0..*) [metadata scheme] sentBy , sentTo and copyTo information is optional, as possibly not applicable in a all technology contexts (e.g. in case of a distributed architecture). Note: MessageInformation corresponds to some of the components of the FpML MessageHeader.model . Timestamp ​ The CDM adopts a generic approach to represent timestamp information, consisting of a dateTime and a qualification attributes, with the latter specified through an enumeration value. type EventTimestamp: dateTime zonedDateTime (1..1) qualification EventTimestampQualificationEnum (1..1) The benefits of the CDM generic approach are twofold: It allows for flexibility in a context where it would be challenging to mandate which points in the process should have associated timestamps. Gathering all of those in one place in the model allows for evaluation and rationalisation down the road. Below is an instance of a CDM representation ( serialised into JSON) of this approach. ""timestamp"": [ { ""dateTime"": ""2007-10-31T18:08:40.335-05:00"", ""qualification"": ""EVENT_SUBMITTED"" }, { ""dateTime"": ""2007-10-31T18:08:40.335-05:00"", ""qualification"": ""EVENT_CREATED"" } ] Event Identifier ​ The Event Identifier provides a unique id that can be used for reference by other workflow steps. The data type is a generic identifier component that is used throughout the product and event models. The event identifier information comprises the assignedIdentifier and an issuer , which may be provided as a reference or via a scheme. type Identifier: [metadata key] issuerReference Party (0..1) [metadata reference] issuer string (0..1) [metadata scheme] assignedIdentifier AssignedIdentifier (1..*) condition IssuerChoice: required choice issuerReference, issuer Note: FpML also uses an event identifier construct: the CorrelationId , but it is distinct from the identifier associated with the trade itself, which comes in different variations: PartyTradeIdentifier , with the TradeId and the VersionedTradeId as sub-components). Other Misc. Attributes ​ The party and account information are optional because not applicable to certain events. The lineage attribute, now deprecated, was previously used to reference an unbounded set of contracts, events and/or payout components that an event may be associated to. Note: The lineage attribute is superseded by the implementation in the CDM of: (i) trade state lineage, via the before reference in the primitive instructions, and (ii) workflow lineage, via the previousWorkflowStep attribute."
Legal_Agreements.txt,"Main Menu Legal Agreements Version: 5.13.0 On this page The Use of Agreements in Financial Markets Financial transactions consist primarily of agreements between parties to make future payments or deliveries to each other. To ensure performance, those agreements typically take the form of legally enforceable contracts, which the parties record in writing to minimize potential future disagreements. It is common practice in some markets for different aspects of these agreements to be recorded in different documents, most commonly dividing those terms that exist at the trading relationship level (e.g. credit risk monitoring and collateral) from those at the transaction level (the economic and risk terms of individual transactions). Relationship agreements and individual transaction level documents are often called ""master agreements"" and ""confirmations"" respectively, and multiple confirmations may be linked to a single master agreement. Both the relationship and transaction level documents may be further divided into those parts that are standard for the relevant market, which may exist in a pre-defined base form published by a trade association or similar body, and those that are more bespoke and agreed by the specific parties. The standard published forms may anticipate that the parties will choose from pre-defined elections in a published form, or create their own bespoke amendments. The ISDA Master Agreement is an internationally recognised document which is used to provide certain legal and credit protection for parties who enter into OTC derivatives. Parties that execute agreements for OTC derivatives are expected to have bi-lateral Master Agreements with each other that cover an agreed range of transactions. Accordingly in the CDM each transaction can be associated with a single master agreement, and a single master agreement can be associated with multiple transactions. In addition to the Master Agreement are sets of credit support documentation which parties may enter into as part of Master Agreement to contain the terms on which they will exchange collateral for their OTC derivatives. Collateral provides protection to a party against the risk that its counterparty defaults and fails to pay the amount that it owes on default. The risk of loss in this scenario is for the current cost of replacing the defaulted transactions (for which margin is called ""variation margin"") and the risk of further loss before the default can be closed out (called ""initial margin"" or ""independent amount""). There are several different types of ISDA credit support document, reflecting variation and initial margin, regulatory requirements and terms for legal relationships under different legal jurisdictions. The key components of the suite of credit support documents are summarized below: Credit Support Annexes (CSAs) exist in New York, English, Irish, French, and Japanese law forms. They define the terms for the provision of collateral by the parties in derivatives transactions, and in some cases they are specialized for initial margin or variation margin. Credit Support Deed CSD (CSD) is very similar to a CSA, except that it is used to create specific types of legal rights over the collateral under English and Irish law, which requires a specific type of legal agreement (a deed). The Collateral Transfer Agreement and Security Agreement (CTA and SA) together define a collateral arrangement where initial margin is posted to a custodian account for use in complying with initial margin requirements. The CTA/SA offers additional flexibility by allowing parties to apply one governing law to the mechanical aspects of the collateral relationship (the CTA) and a different governing law to the grant and enforcement of security over the custodian account (the SA). In the CDM and in this user documentation, legal agreement refers to the written terms of a relationship-level agreement, and contract refers to the written terms defining an executed financial transaction. Legal Agreements in the CDM The CDM provides a digital representation of the legal agreements that govern transactions and workflows. The benefits of this digital representation are summarized below: Supporting marketplace initiatives to streamline and standardise legal agreements with a comprehensive digital representation of such agreements. Providing a comprehensive representation of the financial workflows by complementing the trade and lifecycle event model and formally tying legal data to the business outcome and performance of legal clauses. (e.g. in collateral management where lifecycle processes require reference to parameters found in the associated legal agreements, such as the Credit Support Annex). Supporting the direct implementation of functional processes by providing a normalised representation of legal agreements as structured data, as opposed to the unstructured data contained of a full legal text that needs to be interpreted first before any implementation (e.g. for a calculation of an amount specified in a legal definition). The scope of the CDM legal agreement model includes all of the types of ISDA credit support documents. The legal agreement model is explained below, including examples and references to these types of documents. The topics covered in this section are listed below: Modelling Approach Legal Agreement Data Structure Linking Legal Agreements to contracts Modelling Approach Scope ​ The legal agreement model in the CDM comprises the following features: Composable and normalised model representation of the ISDA agreements. The terms of an ISDA agreement can be defined by identification of the published base document, and the elections or amendments made to that base in a specific legal agreement. There are distinct versions of the published agreements for jurisdiction and year of publication, but the set of elections and amendments to those base agreements often belong to a common universe. Therefore, the CDM defines each of these terms in a single location, and allows for the representation of a specific legal agreement by combining terms where appropriate. The following legal agreements are supported in the CDM: Initial Margin Agreements ISDA 2016 Phase One Credit Support Annex (""CSA"") (Security Interest -- New York Law) ISDA 2016 Phase One Credit Support Deed (""CSD"") (Security Interest -- English Law) ISDA 2016 Phase One CSA (Loan -- Japanese Law) ISDA 2016 ISDA-Clearstream Collateral Transfer Agreement (""CTA"") (New York law and Multi Regime English Law) and Security Agreement ISDA 2016 ISDA-Euroclear CTA (New York law and Multi Regime English Law) and Security Agreement ISDA 2018 CSA (Security Interest -- New York Law) ISDA 2018 CSD (Security Interest -- English Law) ISDA 2019 Bank Custodian CTA and Security Agreement (English Law, New York Law) ISDA 2019 ISDA-Clearstream CTA and Security Agreement (Luxembourg Law -- Security-provider or Security-taker name) ISDA 2019 ISDA-Euroclear CTA and Security Agreement Variation Margin Agreements ISDA 2016 CSA for Variation Margin (""VM"") (Security Interest - New York Law) ISDA 2016 CSA for VM (Title Transfer -- English Law) ISDA 2016 CSA for VM (Loan -- Japanese Law) ISDA 2016 CSA for VM (Title Transfer -- Irish Law) ISDA 2016 CSA for VM (Title Transfer -- French Law) Master Agreement Schedule ISDA 2002 Master Agreement Schedule (Partial agreement representation) Composable and normalised model representation of the eligible collateral schedule for initial and variation margin into a directly machine readable format. Linking of legal agreement into a trade object through the CDM referencing mechanism. Mapping to ISDA Create derivative documentation negotiation platform : Synonyms identified as belonging to ISDA_Create_1_0 have been defined to establish mappings that support automated transformation of ISDA Create documents into objects that are compliant with the CDM. The mapping between the two models through the use of Synonyms validated that all the necessary permutations of elections and data associated with the supported agreements have been replicated in the CDM Ingestion of JSON sample files generated from ISDA Create for samples of executed documents has been implemented in the CDM Portal to demonstrate this capability between ISDA Create and the CDM. More details on Synonyms are provided in the Mapping (Synonym) section of this document. Note: The CDM supports the ISDA CSA for Variation Margin, but this document is not yet represented in ISDA Create - the CDM representation of this document is tested with alternative external sample data. Design Principles ​ The key modelling principles that have been adopted to represent legal agreements are described below: Distinction between the agreement identification features and the agreement content features The agreement identification features: agreement name, publisher (of the base agreement being used), identification, etc. are represented by the LegalAgreementBase type. The agreement content features: elections and amendments to the published agreement, related agreements and umbrella agreement terms are represented by the AgreementTerms . Composite and extendable model . The Legal Agreement model follows the CDM design principles of composability and reusability to develop an extendable model that can support multiple document types. For instance, the LegalAgreementBase data type uses components that are also used as part of the CDM trade and lifecycle event components: e.g. Party , Identifier , date . Normalisation of the data representation Strong data type attributes such as numbers, Boolean, or enumerations are used where possible to create a series of normalised elections within terms used in ISDA documentation and create a data representation of the legal agreement that is machine readable and executable. This approach allows CDM users to define normalised elections into a corresponding legal agreement template to support functional processes. In practice the use of elections expressed in a string format has been restricted, as the string format is generally unsuitable for the support of standardised functional processes. The components of the legal agreement model specified in the CDM are detailed in the section below. Legal Agreement Data Structure The LegalAgreement data type represents the highest-level data type for defining a legal agreement in the CDM. This data type extends the LegalAgreementBase , which contains information to uniquely identify an agreement. There are three non-inherited components to LegalAgreement , as shown in the code snippet below:. type LegalAgreement extends LegalAgreementBase: [metadata key] [rootType] agreementTerms AgreementTerms (0..1) relatedAgreements LegalAgreement (0..*) umbrellaAgreement UmbrellaAgreement (0..1) The LegalAgreementBase , UmbrellaAgreement , and AgreementTerms are defined in the following sections. Agreement Identification ​ The CDM provides support for implementors to uniquely identify a legal agreement solely through the specification of the agreement identification features, as represented in the LegalAgreementBase abstract data type, which is illustrated below: type LegalAgreementBase: agreementDate date (0..1) effectiveDate date (0..1) identifier Identifier (0..*) legalAgreementIdentification LegalAgreementIdentification (1..1) contractualParty Party (2..2) [metadata reference] otherParty PartyRole (0..*) As indicated by the cardinality for the attributes in this data type, all legal agreements must contain an agreement date, two contractual parties, and information indicating the published form of market standard agreement being used (including the name and publisher of the legal agreement being specified in the agreementIdentification attribute). Provision is made for further information to be captured, for example an agreement identifier, which is an optional attribute. Related Agreement ​ Related agreements attribute is used to specify any higher-level agreement(s) that may govern the agreement, either as a reference to such agreements when specified as part of the CDM, or through identification of some of the key terms of those agreements. Note: The LegalAgreementType attribute is used to map related agreement terms that are embedded as part of a transaction message converted from another model structure, such as FpML. For example, this attribute may reference an ISDA Master Agreement, which is not modelled or mapped in the CDM LegalAgreement data type. Umbrella Agreement ​ UmbrellaAgreement is a data type used to specify the applicability of Umbrella Agreement terms, relevant specific language, and underlying entities associated with the umbrella agreement. The below snippet represents the UmbrellaAgreement data type. type UmbrellaAgreement: isApplicable boolean (1..1) language string (0..1) parties UmbrellaAgreementEntity (0..*) Agreement Content ​ AgreementTerms is used to specify the content of a legal agreement in the CDM. There are two components to agreement terms, as shown in the code snippet below: type AgreementTerms: agreement Agreement (1..1) clauseLibrary boolean (0..1) counterparty Counterparty (2..2) The following sections describe each of these components. Agreement ​ Agreement is a data type used to specify the individual elections contained within the legal agreement. It contains a set of encapsulated data types, each containing the elections used to define a specific group of agreements. type Agreement: creditSupportAgreementElections CreditSupportAgreementElections (0..1) collateralTransferAgreementElections CollateralTransferAgreementElections (0..1) securityAgreementElections SecurityAgreementElections (0..1) masterAgreementSchedule MasterAgreementSchedule (0..1) transactionAdditionalTerms TransactionAdditionalTerms (0..1) condition: one-of Counterparty ​ Each counterparty to the agreement is assigned an enumerated value of either Party1 or Party2 through the association of a CounterpartyRoleEnum with the corresponding Party . The CounterpartyRoleEnum value is then used to specify elections throughout the rest of the document. enum CounterpartyRoleEnum: Party1 Party2 type Counterparty: role CounterpartyRoleEnum (1..1) partyReference Party (1..1) [metadata reference] The modelling approach for elective provisions is explained in further detail in the corresponding section below. Elective Provisions This section describes the modelling approach and data structure for election provisions, which are the detailed terms of agreement in each legal document. The section concludes with relevant examples to illustrate the approach and structure. Modelling Approach ​ In many cases the pre-printed clauses in legal agreement templates for OTC Derivatives offer pre-defined elections that the parties can select. In these cases, the clauses are explicitly identified in the agreement templates, including the potential values for each election (e.g. an election from a list of options or a specific type of information such as an amount, date or city). The design of the elective provisions in the CDM to represent these instances is a direct reflection of the choices in the clause and uses boolean attributes or enumeration lists to achieve the necessary outcome. However, in some cases, the agreement template may identify a clause but not all the applicable values, e.g. when a single version of a clause term is provided with a space for parties to agree on a term that is not defined in the template. In order to support these instances, the CDM uses string attributes to capture the clause in a free text format. Election Structure ​ For ease of reference, the structure of the elections contained within each agreement data type in the CDM are modelled to reflect the structure of the legal agreements that they represent. Each data type contains a set of elections or election families which can be used to represent the clauses contained within the corresponding legal agreement, regardless of vintage or governing law. This approach allows the representation of elections in the CDM to focus on their intended business outcome in order to better support the standardisation of related business processes. For example, CreditSupportAgreementElections , which is one of the four agreement types, contains all the elections that may be applicable to a credit support agreement and can be used to define any of the Initial Margin or Variation Margin Credit Support Agreements supported by the CDM: ISDA 2016 Phase One Credit Support Annex (""CSA"") for Initial Margin (""IM"") (Security Interest -- New York Law) ISDA 2016 Phase One Credit Support Deed (""CSD"") for IM (Security Interest -- English Law) ISDA 2016 Phase One CSA for IM (Loan -- Japanese Law) ISDA 2018 CSA for IM (Security Interest -- New York Law) ISDA 2018 CSD for IM (Security Interest -- English Law) ISDA 2016 CSA for Variation Margin (""VM"") (Security Interest - New York Law) ISDA 2016 CSA for VM (Title Transfer -- English Law) ISDA 2016 CSA for VM (Loan -- Japanese Law) ISDA 2016 CSA for VM (Title Transfer -- Irish Law) ISDA 2016 CSA for VM (Title Transfer -- French Law) condition AgreementVerification: if agreementTerms -> agreement -> securityAgreementElections exists then legalAgreementIdentification -> agreementName -> agreementType = LegalAgreementTypeEnum->SecurityAgreement The validation in this case requires that if the securityAgreementElections attribute is populated, then the value in LegalAgreementNameEnum must be SecurityAgreement . Selected examples from two of the agreement data types are explained in the following sections to illustrate the overall approach. The development of a digital data standard for representation of eligible collateral schedules is a crucial component required to drive digital negotiation, straight through processing, and digitisation of collateral management. The standard representation provided within the CDM allows institutions involved in the collateral workflow cycle to exchange eligible collateral information accurately and efficiently in digital form. The EligibleCollateral data type is a root type with one attribute, as shown below: type EligibleCollateralSpecification: [rootType] [metadata key] identifier Identifier (0..*) party Party (0..2) counterparty Counterparty (0..2) criteria EligibleCollateralCriteria (1..*) The EligibleCollateralCriteria data type contains the following key components to allow the digital representation of the detailed criteria reflected in the legal agreement: Collateral Issuer Criteria specifies criteria that the issuer of an asset (if any) must meet when defining collateral eligibility for that asset. Collateral Product Criteria specifies criteria that the product must meet when defining collateral eligibility. Collateral Treatment specifies criteria for the treatment of collateral assets, including whether the asset is identified as eligible or ineligible, and treatment when posted. The following code snippets represent these three components of the eligible collateral model. These components are assembled under the EligibleCollateralCriteria data type, which is contained within the postingObligationElection component of the credit support agreement elections described above. type EligibleCollateralCriteria extends CollateralCriteriaBase: treatment CollateralTreatment (1..1) type CollateralCriteriaBase: issuer IssuerCriteria (0..*) asset AssetCriteria (0..*) appliesTo CounterpartyRoleEnum (0..2) type IssuerCriteria: issuerType CollateralIssuerType (0..*) issuerCountryOfOrigin ISOCountryCodeEnum (0..*) issuerName LegalEntity (0..*) issuerAgencyRating AgencyRatingCriteria (0..*) sovereignAgencyRating AgencyRatingCriteria (0..*) counterpartyOwnIssuePermitted boolean (0..1) type AssetCriteria: collateralAssetType AssetType (0..*) assetCountryOfOrigin ISOCountryCodeEnum (0..*) denominatedCurrency CurrencyCodeEnum (0..*) agencyRating AgencyRatingCriteria (0..*) maturityType MaturityTypeEnum (0..1) maturityRange PeriodRange (0..1) productIdentifier ProductIdentifier (0..*) collateralTaxonomy CollateralTaxonomy (0..*) domesticCurrencyIssued boolean (0..1) listing ListingType (0..1) type CollateralTreatment: valuationTreatment CollateralValuationTreatment (0..1) concentrationLimit ConcentrationLimit (0..*) isIncluded boolean (1..1)"
Namespace.txt,"Main Menu Namespace Version: 5.13.0 Namespace The CDM is partitioned into groups of namespaces. A namespace is an abstract container created to hold a logical grouping of model artefacts. The approach is designed to make it easier for users to understand the model structure and adopt selected components. It also aids the development cycle by insulating groups of components from unrelated model changes that may occur. The partitioning is visible to users in Rosetta Core by toggling the Namespace view in the left hand panel, and in the generated code files. Model Artifacts Model artifacts are organised into a directory hierarchy that is exposed in the model editor. Organising Principles Namespaces are organised into a hierarchy, with layers going from in to out. The hierarchy contains an intrinsic inheritance structure where each layer has access to (""imports"") the layer outside, and is designed to be usable without any of its inner layers. Layers can contain several namespaces (""siblings""), which can also refer to each other. Example -- the base namespace In the example above the layers of the ""base"" namespace can be observed. There are four layers to the namespace. The outer layer ""base"" contains one file and three namespaces. The next layer contains three siblings, ""datetime"", ""math"", and ""staticdata"". A third and fourth layer is contained within the ""staticdata"" namespace. Hierarchy Structure The namespace hierarchy in the CDM contains 7 components Base -- contains basic concepts used across the model: date, time, maths, static data Event -- contains business event concepts: primitive, contract state, and associated state transition function specifications Legal Agreement -- contains generic documentation concepts: legal agreement, contract, and credit support specifications Observable -- contains observable concepts: market data, holiday calendars, asset class specific specifications Product -- contains generic product concepts: quantity, price, economic terms and payout, that are built using template features Regulation -- contains regulation concepts: regulatory bodies, corpus, report definitions and field rules Synonym -- contains model to model synonym mappings"
Main_Menu.txt,Main Menu Homepage Version: 5.13.0 Homepage Welcome to CDM documentation ! Overview of Finos CDM The Common Domain Model product-model event-model legal-agreements process-model reference-data-model mapping namespace Use Cases Eligible Collateral Representation Repurchase Agreement Representation Securities Lending Pre-trade Processing CDM Java Distribution Guidelines Development Guidelines CDM Materials CDM Demos Get Involved Join the Contribution Review Working Group Join the Collateral Working Group Join the Steering Working Group Join the Structured Products Working Group Join the Technology Architecture Working Group Join the Derivatives Product and Business Event Working Group Download
Repurchase_Transaction_Representation_in_the_CDM.txt,"Main Menu Repurchase Transaction Representation in the CDM Version: 5.13.0 On this page Background The FINOS CDM for Repo and Bonds initiative is intended to support the digitalization of the repo market through the adoption of a standardized domain model and lifecycle events based on industry best practices and standards. The ICMA promotes adoption of CDM by organizing working groups and workshops on proof-of-concept projects and integration. The repo elements of the model were designed with participation and contribution of the FINOS CDM for Repo and Bonds Steering Committee. Introduction The repo product model in the CDM does not follow any pre-defined taxonomy such as FpML or any regulatory model such as SFTR. Instead the repo model is agnostic to external models, messaging standards and technology. The fundmental concepts in the repo model are based on industry defintions of financial products, the GMRA and the ERCC Best Practices Guide. Repurchase transactions are represented in the CDM as contractual products, which are products with custom payout structures and assets. The types of repo products that can be defined in the CDM is almost unlimited using the InterestRatePayout and AssetPayout structure. At a minimum the model supports basic repo transactions, fixed term repo, open repo, fixed rate and floating rate with optionality for early termination, evergreen and extendible. The model also support buy/sell-back transactions. Repo lifecycle events are supported through a set of functions that accept a small set of inputs to auto-generate primitive instructions needed to execute business events. Repo lifecycle events include, rolling, re-rating, interium payments, pair-off and shaping. Benefits The benefits of using the CDM for repo transactions is that it provides a standard digital representation of the data required to define a repo product and a standardized set of lifecyle events. Examples of where the CDM can be used in the repo market: Post-trade matching using a single digital object. Lifecycle event processing across counterparties and settlement services. Internal and external reporting. Capturing event history. Market standard taxonomy and mapping interface to other platforms. ICMA Contacts: - - - - - - - - - - - -Gabriel Callsen, Director gabriel.callsen@icmagroup.org +44 (0)20 7213 0334 Tom Healey, FINXIS LLC, Consultant tom.healey@icmagroup.org Scope The scope of the CDM Repo initiative was intended to define: Consistent definition of buyer-seller entities based on LEI data Collateral, margin anf haircut attributes. Flexible interest rate payout model to support complex structures. Standardized product taxonomy. Predefine lifecycle event processing and event history. Repo Product Model Building upon the CDM, the Repo CDM added new data types, attributes and events needed to create fixed term, open and floating rate repos, and execute various lifecycle events. A repo product is formed from a ContractualProduct as an extension of ProductBase. The payout structure for a repo is constructed using an InterestRatePayout for the cash loan and AssetPayout for the collateral. Payer and Receiver ​ The InterestRatePayout object must also define the payer and receiver. They payer and receiver are linked to the trade object that defines the counterparty and partyrole. In a repo transaction, the seller (collateral giver - borrower) will be the payer and the buyer(collateral taker -- lender) will be receiver. The payer and receiver are extensions from the PayoutBase. Collateral ​ Collateral on a repo transaction is defined using AssetPayout . Security identification is set in the securityInformation attribute, which itself is a Product allowing for the possibility of creating products defined in terms of other products. Collateral may also be defined using parameters such as currency, country, maturity and other attributes available in CollateralProvisions to classify Purchase Date and Repurchase Date ​ In economicTerms , the effectiveDate attribute represents the repo purchase date and the terminationDate is the repurchase date. For an open repo the terminationDate is not set until the repo terminates. The external and global key references should include \""PurchaseDate and \""RepurchaseDate\"": ""effectiveDate"": { ""adjustableDate"": { ""dateAdjustments"": { ""businessCenters"": { ""businessCenter"": [ { ""value"": ""GBLO"" } ] }, ""businessDayConvention"": ""NONE"" }, ""unadjustedDate"": ""2023-06-16"" }, ""meta"": { ""externalKey"": ""PurchaseDate"", ""globalKey"": ""PurchaseDate"" } } ""terminationDate"": { ""adjustableDate"": { ""dateAdjustments"": { ""businessDayConvention"": ""NONE"", ""meta"": { ""externalKey"": ""RepurchaseDate"", ""globalKey"": ""RepurchaseDate"" } }, ""unadjustedDate"": ""2023-06-17"" } } Repurchase transactions should also include tags to identify the purchase price and repurchase price. In the interestRatePayout and purchase price is set on the priceQuantity and the initialPayment : ""priceQuantity"": { ""meta"": { ""externalKey"": ""PurchasePrice"" }, ""quantitySchedule"": { ""value"": { ""unit"": { ""currency"": { ""value"": ""GBP"" } }, ""value"": 9879046.8 } }, ""resolvedQuantity"": { ""unit"": { ""currency"": { ""value"": ""GBP"" } }, ""value"": 9879046.8 } } Repurchase transactions should also include the a legal agreement object with reference to the GMRA or other private agreement by adding the legalAgreementIdentification object: ""contractDetails"": { ""documentation"": [ { ""legalAgreementIdentification"": { ""agreementName"": { ""masterAgreementType"": { ""value"": ""GMRA"" } }, ""governingLaw"": ""GBEN"", ""publisher"": ""ICMA"", ""vintage"": 2011 } } ] } Collateral is defined in assetPayout->securityInformation : ""securityInformation"": { ""security"": { ""productIdentifier"": [ { ""value"": { ""identifier"": { ""value"": ""GB00B24FF097"" }, ""source"": ""ISIN"" }], ""securityType"": ""DEBT"" } } } Repurchase transactions are classified as a MoneyMarket types using AssetClassEnum , but this attribute is optional and is not required to qualify a trade. Haircut and Margin ​ Most repo trades include a haircut or margin adjustment to the collateral value that affords the collateral holder a level of risk protection. Haircuts and margin adjustments are set on the collateralProvision attribute under economicTerms->collateral->collateralProvisions . Haircuts in json format appear as: ""collateralProvisions"": { ""eligibleCollateral"": [ { ""criteria"": [ { ""treatment"": { ""valuationTreatment"": { ""haircutPercentage"": 2 } } } ] } ] } Repurchase Transaction Example ​ Example: Fixed Term, Fixed Rate bi-lateral repo A fixed term, fixed rate bilateral repo transaction is a transaction between two counterparties to exchange cash for collateral at an agreed interest rate for an agreed fixed term. On the effective date the seller delivers collateral to the buyer and receives cash. On the termination date the buyer returns collateral to the seller and receives the cash principal plus interest. As previously described, to build a repo product the following components are needed: Purchase Date Repurchase Date Buyer Seller Repo Rate Collateral Haircut Purchase Price Repurchase Price Legal Agreement A fixed term, fixed rate repo example json structure can be found here: Fixed-Term,Fixed-Rate Repo Product :download:json \<code-snippets/fixed-term-fixed-rate-repo-product.json > The priceQuantity object is used to define the collateral value and repo rate. The repo rate is defined as a price with a priceTypeEnum value of ""INTEREST_RATE"". ""price"": [ { ""meta"": {}, ""value"": { ""unit"": { ""currency"": { ""value"": ""GBP"" } }, ""value"": 0.004, ""perUnitOf"": { ""currency"": { ""value"": ""GBP"" } }, ""priceExpression"": { ""priceType"": ""INTEREST_RATE"" } }}] The priceQuantity object is also used to define the collateral price and value: ""quantity"": [ { ""meta"": {}, ""value"": { ""unit"": { ""currency"": { ""value"": ""GBP"" } }, ""value"": 9974250 }}] Collateral amount is defined in terms of the nominal par amount: ""quantity"": [ { ""meta"": {}, ""value"": { ""unit"": { ""currency"": { ""value"": ""GBP"" }}, ""value"": 10000000 }}] The collateral price can be defined as either Clean or Dirty price: ""price"": [ { ""meta"": {}, ""value"": { ""unit"": { ""currency"": { ""value"": ""GBP"" } }, ""value"": 1.0075, ""perUnitOf"": { ""currency"": { ""value"": ""GBP"" } }, ""priceExpression"": { ""cleanOrDirty"": ""DIRTY"", ""priceExpression"": ""PERCENTAGE_OF_NOTIONAL"", ""priceType"": ""ASSET_PRICE"" }}}] Counterparties are defined in the counterparty object and need to define the role attribute as PARTY_1 or PARTY_2 as it relates to the counterparty being the buyer or seller. {""partyReference"": { ""value"": { ""meta"": { ""externalKey"": ""UkBank"", ""globalKey"": ""1ef4886d"" }, ""name"": { ""value"": ""UK Bank plc"" } } }, ""role"": ""PARTY_2"" }] {""partyReference"": { ""value"": { ""meta"": { ""externalKey"": ""UkBank"", ""globalKey"": ""1ef4886d"" }, ""name"": { ""value"": ""UK Bank plc"" }}}, ""role"": ""PARTY_2"" }] partyRoles ​ PartyRoles are necessary to define the buyer (cash lender) and seller (collateral giver). A reference global key is used to link the party role to the party defined in the party object: ""partyRoles"": [{ ""partyReference"": { ""externalReference"": ""GlobalBank"", ""globalReference"": ""296093b7"" }, ""role"": ""SELLER"" }, {""partyReference"": { ""externalReference"": ""UkBank"", ""globalReference"": ""1ef4886d"" }, ""role"": ""BUYER"" }] Trade Date ​ Trade Date is a simple date string: ""tradeDate"": ""2021-03-18"" Executing Business Event ​ Executing events in the CDM is performed by calling Create_BusinessEvent using one or more valid Instructions: To represent the repurchase agreement using the CFI taxonomy the json would look like: ""productTaxonomy"": [ { ""source"": ""CFI"", ""value"": { ""name"": { ""value"": ""LRSTXD"" } } }, { ""productQualifier"": ""Repurchase Agreement"", ""taxonomySource"": ""CFI"" }] Lifecycle Events Lifecycle events are actions that modify or close transactions. These actions may be taken by a counterparty or automatically generated due to events such as rate changes, contract changes, extensions, or terminations. Repo lifecycle events are important to the daily functioning of the market but also a source of errors and failures caused by different methodologies implemented by systems for the same event or mismatches in data, workflow and calculations. The CDM provides a software implementation based on industry practice and ERCC Best Practices industry intended to reduce mismatches in workflow and data. In the CDM a lifecycle event results in a state transition. State changes are trade specific and are automatically linked in the CDM. All repo events follow the CDM Event Model design and process. Initiating a repo event requires the creation of an event primitive instruction followed by a call to Create_BusinessEvent. Using an instantiated repo trade that was created with a repo execution will result in a TradeState object and the state is positionState=Executed. Repo events currently supported in the CDM include: Execution Roll Re-Rate Early Termination Pair-off Shaping On Demand Interest Payment"
CDM_Technology_Architecture_Working_Group.txt,"Main Menu CDM Technology Architecture Working Group Version: 5.13.0 On this page CDM Technology Architecture Working Group Overview ​ The CDM Technology Architecture Working Group focuses on aligning the architecture, tooling services, infrastructure, development practices, and deployment of the CDM with both existing and future technologies. Responsibilities ​ Defining and working on technical aspects and architecture-related items, such as language distributions, packaging, libraries, serialization, reference data architecture, and integration with other data standards. Collaborating closely with the CDM Contribution Review Working Group. Meeting monthly, with the flexibility to form sub-groups as necessary to address specific technical challenges or opportunities. Meetings ​ Join us every 2nd Thursday of Every Month, 9AM EST (2PM GMT). Email to be added to the meeting invites directly, or find the meeting in the . 2024 Roadmap ​ ​ To subscribe to the TAWG mailing list and stay updated on meetings and agenda, please send an email to cdm-technology-architecture+subscribe@lists.finos.org . After sending the email, you will receive a confirmation message. Reply to confirm your subscription. To view meeting notes and agendas, view our current and past GitHub Meeting Issues."
